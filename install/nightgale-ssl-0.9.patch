diff -rupN openssl-1.1.0f/compile_night_test.sh openssl/compile_night_test.sh
--- openssl-1.1.0f/compile_night_test.sh	1969-12-31 16:00:00.000000000 -0800
+++ openssl/compile_night_test.sh	2017-06-05 18:33:49.652024646 -0700
@@ -0,0 +1,8 @@
+rm -f night_test
+rm -f night_evp_test
+./config && make update && make -j 12 && \
+gcc -I./include -L. -Wextra -Wall -o night_evp_test night_evp_test.c -lcrypto && \
+gcc -I./include -L. -Wextra -Wall -o night_test night_test.c -lcrypto && \
+LD_LIBRARY_PATH=. ./night_test && \
+LD_LIBRARY_PATH=. ./night_evp_test && \
+LD_LIBRARY_PATH=. ./apps/openssl speed -elapsed -evp nightgale
diff -rupN openssl-1.1.0f/Configure openssl/Configure
--- openssl-1.1.0f/Configure	2017-05-25 05:46:17.000000000 -0700
+++ openssl/Configure	2017-06-05 18:23:55.221677432 -0700
@@ -308,7 +308,7 @@ $config{dirs} = [ "crypto", "ssl", "engi
 $config{sdirs} = [
     "objects",
     "md2", "md4", "md5", "sha", "mdc2", "hmac", "ripemd", "whrlpool", "poly1305", "blake2",
-    "des", "aes", "rc2", "rc4", "rc5", "idea", "bf", "cast", "camellia", "seed", "chacha", "modes",
+    "des", "aes", "nightgale", "rc2", "rc4", "rc5", "idea", "bf", "cast", "camellia", "seed", "chacha", "modes",
     "bn", "ec", "rsa", "dsa", "dh", "dso", "engine",
     "buffer", "bio", "stack", "lhash", "rand", "err",
     "evp", "asn1", "pem", "x509", "x509v3", "conf", "txt_db", "pkcs7", "pkcs12", "comp", "ocsp", "ui",
diff -rupN openssl-1.1.0f/crypto/evp/build.info openssl/crypto/evp/build.info
--- openssl-1.1.0f/crypto/evp/build.info	2017-05-25 05:46:18.000000000 -0700
+++ openssl/crypto/evp/build.info	2017-06-05 18:21:58.978214262 -0700
@@ -3,7 +3,7 @@ SOURCE[../../libcrypto]=\
         encode.c digest.c evp_enc.c evp_key.c evp_cnf.c \
         e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
         e_rc4.c e_aes.c names.c e_seed.c \
-        e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
+        e_night.c e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
         m_null.c m_md2.c m_md4.c m_md5.c m_sha1.c m_wp.c \
         m_md5_sha1.c m_mdc2.c m_ripemd.c \
         p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
diff -rupN openssl-1.1.0f/crypto/evp/c_allc.c openssl/crypto/evp/c_allc.c
--- openssl-1.1.0f/crypto/evp/c_allc.c	2017-05-25 05:46:18.000000000 -0700
+++ openssl/crypto/evp/c_allc.c	2017-06-05 18:22:30.781517173 -0700
@@ -17,6 +17,9 @@
 void openssl_add_all_ciphers_int(void)
 {
 
+    EVP_add_cipher(EVP_nightgale());
+    EVP_add_cipher_alias(SN_nightgale, "nightgale");
+
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cfb());
     EVP_add_cipher(EVP_des_cfb1());
diff -rupN openssl-1.1.0f/crypto/evp/e_night.c openssl/crypto/evp/e_night.c
--- openssl-1.1.0f/crypto/evp/e_night.c	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/evp/e_night.c	2017-06-05 18:19:55.291950715 -0700
@@ -0,0 +1,58 @@
+#include <stdio.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/nightgale.h>
+#include "internal/cryptlib.h"
+#include "internal/evp_int.h"
+
+typedef struct {
+	SUB s;
+	union {
+		void (*cipher) (SUB *s, size_t len, const unsigned char *in,
+                                    unsigned char *out);
+	} stream;
+} EVP_NIGHT_KEY;
+
+#define data(ctx) ((EVP_NIGHT_KEY *)EVP_CIPHER_CTX_get_cipher_data(ctx))
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+				const unsigned char *iv, int enc);
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl);
+
+static const EVP_CIPHER nightgale_cipher = {
+	NID_nightgale,
+	1, 1, 0, // block_size, key size, iv size 
+	0,
+	nightgale_init_key, // function pointer to key init
+	nightgale_c, // function pointer to cipher operation
+	NULL, // clean up function pointer
+	sizeof(EVP_NIGHT_KEY), // size of ctx
+	NULL,
+	NULL,
+	NULL,
+	NULL	
+};
+
+const EVP_CIPHER *EVP_nightgale(void)
+{
+	return (&nightgale_cipher);
+}
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                                const unsigned char *iv, int enc)
+{
+	enc ? nightgale_enc_set_key(&data(ctx)->s) : 
+			nightgale_dec_set_key(&data(ctx)->s);
+	data(ctx)->stream.cipher = enc ? encrypt_night : decrypt_night;
+	return 1;
+}
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl)
+{
+	(*data(ctx)->stream.cipher) (&data(ctx)->s, inl, in, out);
+	return 1;
+}
+
diff -rupN openssl-1.1.0f/crypto/nightgale/build.info openssl/crypto/nightgale/build.info
--- openssl-1.1.0f/crypto/nightgale/build.info	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/build.info	2017-06-05 18:19:46.922137515 -0700
@@ -0,0 +1,3 @@
+LIBS=../../libcrypto
+SOURCE[../../libcrypto]=\
+sub_t.c nightgale_c.c
diff -rupN openssl-1.1.0f/crypto/nightgale/nightgale_c.c openssl/crypto/nightgale/nightgale_c.c
--- openssl-1.1.0f/crypto/nightgale/nightgale_c.c	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/nightgale_c.c	2017-06-05 18:19:46.922137515 -0700
@@ -0,0 +1,98 @@
+#include "nightgale_c.h"
+
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char* in, 
+                    unsigned char * out){
+
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)out;
+    uint64_t *plain_text = (uint64_t *)in;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word;
+
+    // Encrypt buffers
+    root = anchor;
+    for(int i = 0; i < word_count; ++i){
+        decimal_word = root ^ plain_text[i] ^ hamming_mask;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int k = 0; k < WORD_SIZE; ++k) pre_sub[k] = s->sub[(int)pre_sub[k]];
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        enc_message[i] = decimal_word ^ key ^ anchor;
+        root = decimal_word;
+    }
+ }
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                                unsigned char *out){
+    
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)in;
+    uint64_t *dec_message = (uint64_t *)out;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word, pre_sub_decimal_word;
+
+    // Decrypt here
+    root = anchor;
+    for(int i = 0; i < word_count; ++i) {
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        decimal_word = enc_message[i] ^ key ^ anchor;
+	pre_sub_decimal_word = decimal_word;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int j = 0; j < WORD_SIZE; ++j) pre_sub[j] = s->reverse_sub[(int)pre_sub[j]];
+        dec_message[i] = root ^ decimal_word ^ hamming_mask;
+        root = pre_sub_decimal_word;
+    }
+}
+
diff -rupN openssl-1.1.0f/crypto/nightgale/nightgale_c.h openssl/crypto/nightgale/nightgale_c.h
--- openssl-1.1.0f/crypto/nightgale/nightgale_c.h	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/nightgale_c.h	2017-06-05 18:19:46.922137515 -0700
@@ -0,0 +1,32 @@
+#ifndef HEADER_NIGHTGALE_H
+#define HEADER_NIGHTGALE_H
+
+#include "pcg_variants.h"
+#include "sub_t.h"
+
+#define WORD_SIZE 8
+#define MASK 0xfc00000000000000
+
+//-----------------------------------------------------------------------------
+// Encrypt
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char *in, 
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Decrypt
+//-----------------------------------------------------------------------------
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Anchor rotation
+//-----------------------------------------------------------------------------
+inline uint64_t rotr64 (uint64_t n, unsigned int c){
+    const unsigned int mask = (CHAR_BIT*sizeof(n)-1);
+    c &= mask;
+    return (n>>c) | (n<<( (-c)&mask ));
+}
+
+#endif
+
diff -rupN openssl-1.1.0f/crypto/nightgale/pcg_variants.h openssl/crypto/nightgale/pcg_variants.h
--- openssl-1.1.0f/crypto/nightgale/pcg_variants.h	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/pcg_variants.h	2017-06-05 18:19:46.923137493 -0700
@@ -0,0 +1,351 @@
+/*
+ * PCG Random Number Generation for C.
+ *
+ * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * For additional information about the PCG random number generation scheme,
+ * including its license and other licensing options, visit
+ *
+ *     http://www.pcg-random.org
+ */
+
+/*
+ * This code is derived from the canonical C++ PCG implementation, which
+ * has many additional features and is preferable if you can use C++ in
+ * your project.
+ *
+ * Much of the derivation was performed mechanically.  In particular, the
+ * output functions were generated by compiling the C++ output functions
+ * into LLVM bitcode and then transforming that using the LLVM C backend
+ * (from https://github.com/draperlaboratory/llvm-cbe), and then
+ * postprocessing and hand editing the output.
+ *
+ * Much of the remaining code was generated by C-preprocessor metaprogramming.
+
+pcg-advance-16.c pcg-advance-16.c\
+    pcg-advance-8.c pcg-global-32.c pcg-global-32.c\
+    pcg-global-32.c pcg-output-32.c pcg-output-8.c\
+    pcg-output-8.c pcg-rngs-16.c pcg-rngs-16.c\
+    pcg-rngs-8.c
+ 
+ */
+
+#ifndef PCG_VARIANTS_H_INCLUDED
+#define PCG_VARIANTS_H_INCLUDED 1
+
+#include <inttypes.h>
+
+#if __SIZEOF_INT128__
+    typedef __uint128_t pcg128_t;
+    #define PCG_128BIT_CONSTANT(high,low) \
+            ((((pcg128_t)high) << 64) + low)
+    #define PCG_HAS_128BIT_OPS 1
+#endif
+
+#if __GNUC_GNU_INLINE__  &&  !defined(__cplusplus)
+    #error Nonstandard GNU inlining semanatics. Compile with -std=c99 or better.
+    // We could instead use macros PCG_INLINE and PCG_EXTERN_INLINE
+    // but better to just reject ancient C code.
+#endif
+
+/*
+ * Rotate helper functions.
+ */
+
+inline uint8_t pcg_rotr_8(uint8_t value, unsigned int rot)
+{
+/* Unfortunately, clang is kinda pathetic when  it comes to properly
+ * recognizing idiomatic rotate code, so for clang we actually provide
+ * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss.
+ */
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorb   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 7));
+#endif
+}
+
+inline uint16_t pcg_rotr_16(uint16_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorw   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 15));
+#endif
+}
+
+inline uint32_t pcg_rotr_32(uint32_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorl   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 31));
+#endif
+}
+
+inline uint64_t pcg_rotr_64(uint64_t value, unsigned int rot)
+{
+#if 0 && PCG_USE_INLINE_ASM && __clang__ && __x86_64__
+    // For whatever reason, clang actually *does* generator rotq by
+    // itself, so we don't need this code.
+    asm ("rorq   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 63));
+#endif
+}
+
+/*
+ * Output functions.  These are the core of the PCG generation scheme.
+ */
+
+
+
+
+
+
+// XSL RR (only defined for >= 64 bits)
+
+inline uint64_t pcg_output_xsl_rr_128_64(pcg128_t state)//////////////////////////////////////////////////////////////////////////////
+{
+    return pcg_rotr_64(((uint64_t)(state >> 64u)) ^ (uint64_t)state,
+                       state >> 122u);
+}
+
+
+#define PCG_DEFAULT_MULTIPLIER_8   141U
+#define PCG_DEFAULT_MULTIPLIER_16  12829U
+#define PCG_DEFAULT_MULTIPLIER_32  747796405U
+#define PCG_DEFAULT_MULTIPLIER_64  6364136223846793005ULL
+
+#define PCG_DEFAULT_INCREMENT_8    77U
+#define PCG_DEFAULT_INCREMENT_16   47989U
+#define PCG_DEFAULT_INCREMENT_32   2891336453U
+#define PCG_DEFAULT_INCREMENT_64   1442695040888963407ULL
+
+#define PCG_DEFAULT_MULTIPLIER_128 \
+        PCG_128BIT_CONSTANT(2549297995355413924ULL,4865540595714422341ULL)
+#define PCG_DEFAULT_INCREMENT_128  \
+        PCG_128BIT_CONSTANT(6364136223846793005ULL,1442695040888963407ULL)
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG_STATE_ONESEQ_8_INITIALIZER      { 0xd7U }
+#define PCG_STATE_ONESEQ_16_INITIALIZER     { 0x20dfU }
+#define PCG_STATE_ONESEQ_32_INITIALIZER     { 0x46b56677U }
+#define PCG_STATE_ONESEQ_64_INITIALIZER     { 0x4d595df4d0f33173ULL }
+#define PCG_STATE_ONESEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0xb8dc10e158a92392ULL, 0x98046df007ec0a53ULL) }
+
+#define PCG_STATE_UNIQUE_8_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG_STATE_UNIQUE_16_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG_STATE_UNIQUE_32_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG_STATE_UNIQUE_64_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG_STATE_UNIQUE_128_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG_STATE_MCG_8_INITIALIZER         { 0xe5U }
+#define PCG_STATE_MCG_16_INITIALIZER        { 0xa5e5U }
+#define PCG_STATE_MCG_32_INITIALIZER        { 0xd15ea5e5U }
+#define PCG_STATE_MCG_64_INITIALIZER        { 0xcafef00dd15ea5e5ULL }
+#define PCG_STATE_MCG_128_INITIALIZER                                          \
+    { PCG_128BIT_CONSTANT(0x0000000000000000ULL, 0xcafef00dd15ea5e5ULL) }
+
+#define PCG_STATE_SETSEQ_8_INITIALIZER      { 0x9bU, 0xdbU }
+#define PCG_STATE_SETSEQ_16_INITIALIZER     { 0xe39bU, 0x5bdbU }
+#define PCG_STATE_SETSEQ_32_INITIALIZER     { 0xec02d89bU, 0x94b95bdbU }
+#define PCG_STATE_SETSEQ_64_INITIALIZER                                        \
+    { 0x853c49e6748fea9bULL, 0xda3e39cb94b95bdbULL }
+#define PCG_STATE_SETSEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0x979c9a98d8462005ULL, 0x7d3e9cb6cfe0549bULL),       \
+      PCG_128BIT_CONSTANT(0x0000000000000001ULL, 0xda3e39cb94b95bdbULL) }
+
+/* Representations for the oneseq, mcg, and unique variants */
+
+struct pcg_state_8 {
+    uint8_t state;
+};
+
+struct pcg_state_16 {
+    uint16_t state;
+};
+
+struct pcg_state_32 {
+    uint32_t state;
+};
+
+struct pcg_state_64 {
+    uint64_t state;
+};
+
+struct pcg_state_128 {
+    pcg128_t state;
+};
+
+/* Representations setseq variants */
+
+struct pcg_state_setseq_8 {
+    uint8_t state;
+    uint8_t inc;
+};
+
+struct pcg_state_setseq_16 {
+    uint16_t state;
+    uint16_t inc;
+};
+
+struct pcg_state_setseq_32 {
+    uint32_t state;
+    uint32_t inc;
+};
+
+struct pcg_state_setseq_64 {
+    uint64_t state;
+    uint64_t inc;
+};
+
+struct pcg_state_setseq_128 {
+    pcg128_t state;
+    pcg128_t inc;
+};
+
+
+/* Functions to advance the underlying LCG, one version for each size and
+ * each style.  These functions are considered semi-private.  There is rarely
+ * a good reason to call them directly.
+ */
+
+
+
+/* Functions to seed the RNG state, one version for each size and each
+ * style.  Unlike the step functions, regular users can and should call
+ * these functions.
+ */
+
+
+
+
+
+inline void pcg_setseq_128_step_r(struct pcg_state_setseq_128* rng)/////////////////////////////////////////////////////////////////////////////
+{
+    rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128 + rng->inc;
+}
+
+inline void pcg_setseq_128_srandom_r(struct pcg_state_setseq_128* rng,////////////////////////////////////////////////////////////////////////////
+                                     pcg128_t initstate, pcg128_t initseq)
+{
+    rng->state = 0U;
+    rng->inc = (initseq << 1u) | 1u;
+    pcg_setseq_128_step_r(rng);
+    rng->state += initstate;
+    pcg_setseq_128_step_r(rng);
+}
+
+/* Now, finally we create each of the individual generators. We provide
+ * a random_r function that provides a random number of the appropriate
+ * type (using the full range of the type) and a boundedrand_r version
+ * that provides
+ *
+ * Implementation notes for boundedrand_r:
+ *
+ *     To avoid bias, we need to make the range of the RNG a multiple of
+ *     bound, which we do by dropping output less than a threshold.
+ *     Let's consider a 32-bit case...  A naive scheme to calculate the
+ *     threshold would be to do
+ *
+ *         uint32_t threshold = 0x100000000ull % bound;
+ *
+ *     but 64-bit div/mod is slower than 32-bit div/mod (especially on
+ *     32-bit platforms).  In essence, we do
+ *
+ *         uint32_t threshold = (0x100000000ull-bound) % bound;
+ *
+ *     because this version will calculate the same modulus, but the LHS
+ *     value is less than 2^32.
+ *
+ *     (Note that using modulo is only wise for good RNGs, poorer RNGs
+ *     such as raw LCGs do better using a technique based on division.)
+ *     Empricical tests show that division is preferable to modulus for
+ *     reducting the range of an RNG.  It's faster, and sometimes it can
+ *     even be statistically prefereable.
+ */
+
+/* Generation functions for XSH RS */
+
+
+inline uint64_t
+pcg_setseq_128_xsl_rr_64_random_r(struct pcg_state_setseq_128* rng)///////////////////////////////////////////////////////////////////////
+{
+    pcg_setseq_128_step_r(rng);
+    return pcg_output_xsl_rr_128_64(rng->state);
+}
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_64      pcg32_random_t;
+typedef struct pcg_state_64             pcg32s_random_t;
+typedef struct pcg_state_64             pcg32u_random_t;
+typedef struct pcg_state_64             pcg32f_random_t;
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_128     pcg64_random_t;
+typedef struct pcg_state_128            pcg64s_random_t;
+typedef struct pcg_state_128            pcg64u_random_t;
+typedef struct pcg_state_128            pcg64f_random_t;
+//// random_r
+#define pcg64_random_r                  pcg_setseq_128_xsl_rr_64_random_r
+
+//// srandom_r
+#define pcg64_srandom_r                 pcg_setseq_128_srandom_r
+
+
+ uint64_t pcg64_random();
+ void     pcg64_srandom(pcg128_t seed, pcg128_t seq);
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG32_INITIALIZER       PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG32U_INITIALIZER      PCG_STATE_UNIQUE_64_INITIALIZER
+#define PCG32S_INITIALIZER      PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG32F_INITIALIZER      PCG_STATE_MCG_64_INITIALIZER
+
+#define PCG64_INITIALIZER       PCG_STATE_SETSEQ_128_INITIALIZER
+#define PCG64U_INITIALIZER      PCG_STATE_UNIQUE_128_INITIALIZER
+#define PCG64S_INITIALIZER      PCG_STATE_ONESEQ_128_INITIALIZER
+#define PCG64F_INITIALIZER      PCG_STATE_MCG_128_INITIALIZER
+
+#define PCG8SI_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG16SI_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG32SI_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG64SI_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG128SI_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG8I_INITIALIZER       PCG_STATE_SETSEQ_8_INITIALIZER
+#define PCG16I_INITIALIZER      PCG_STATE_SETSEQ_16_INITIALIZER
+#define PCG32I_INITIALIZER      PCG_STATE_SETSEQ_32_INITIALIZER
+#define PCG64I_INITIALIZER      PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG128I_INITIALIZER     PCG_STATE_SETSEQ_128_INITIALIZER
+
+#endif // PCG_VARIANTS_H_INCLUDED
+
diff -rupN openssl-1.1.0f/crypto/nightgale/sub_t.c openssl/crypto/nightgale/sub_t.c
--- openssl-1.1.0f/crypto/nightgale/sub_t.c	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/sub_t.c	2017-06-05 18:19:46.923137493 -0700
@@ -0,0 +1,170 @@
+#include "sub_t.h"
+
+//-----------------------------------------------------------------------------
+void nightgale_dec_set_key(SUB *s){
+    generate_hash(s, RSA_KEY);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s){
+    generate_key(s);
+    generate_hash(s, RSA_KEY);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+size_t get_file_length(FILE *fp) {
+    fseek(fp, 0L, SEEK_CUR);
+    long unsigned int mypos = ftell(fp);
+    fseek(fp, 0L, SEEK_END);
+    long unsigned int filesize = ftell(fp);
+    fseek(fp, mypos, SEEK_SET);
+    return filesize;
+ }
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne){
+    BIO_free_all(bp_private);
+    RSA_free(r);
+    BN_free(bne);
+}
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void *elem1, const void *elem2){
+    indexes *i1, *i2;
+    i1 = (indexes *)elem1;
+    i2 = (indexes *)elem2;
+    return i1->value - i2->value;
+}
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s){
+    indexes knuth_sort[SUB_SIZE];
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        knuth_sort[i].index = i+1;
+        knuth_sort[i].value = s->sub_rands[i];
+    }
+
+    qsort(knuth_sort, SUB_SIZE, sizeof(indexes), cmp);
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        s->sub[i] = (unsigned char)knuth_sort[i].index;
+        s->reverse_sub[(unsigned char)knuth_sort[i].index] = i;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s){
+    pcg64_random_t rng1, rng2, rng3, rng4;
+    pcg128_t round = 5;
+    pcg128_t s1, s2, s3, s4;
+
+    void *temp;
+
+    temp = s->seed1;
+    s1 = *(pcg128_t *)temp;
+    
+    temp = s->seed2;
+    s2 = *(pcg128_t *)temp;
+
+    temp = s->seed3;
+    s3 = *(pcg128_t *)temp;
+
+    temp = s->seed4;
+    s4 = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng1, s1, round);
+    pcg64_srandom_r(&rng2, s2, round);
+    pcg64_srandom_r(&rng3, s3, round);
+    pcg64_srandom_r(&rng4, s4, round);
+
+    for(int i = 0; i < 64; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng1);
+    }
+    for(int i = 64; i < 128; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng2);
+    }
+    for(int i = 128; i < 192; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng3);
+    }
+    for(int i = 192; i < 256; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng4);
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s){
+    memcpy(s->seed1, s->hash, SEED_SIZE);
+    memcpy(s->seed2, s->hash + SEED_SIZE, SEED_SIZE);
+    memcpy(s->seed3, s->hash + SEED_SIZE*2, SEED_SIZE);
+    memcpy(s->seed4, s->hash + SEED_SIZE*3, SEED_SIZE);
+}
+
+//-----------------------------------------------------------------------------
+// Generate Hash from private key file from RSA
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const char* key_file){
+    FILE *fp = fopen(key_file, "rb");
+    if( !fp ) perror("Error reading private key from RSA."),exit(EXIT_FAILURE);
+
+    size_t filesize = get_file_length(fp);
+    unsigned char *buffer = malloc(filesize);
+    size_t nread = fread(buffer, sizeof(unsigned char), filesize, fp);
+
+    if( ferror(fp) || nread != filesize) perror("Error reading private key from RSA."),
+                        exit(EXIT_FAILURE);
+
+    SHA512(buffer, filesize, s->hash);
+    SHA256(s->hash, SHA512_DIGEST_LENGTH, s->digest);
+
+    free(buffer);
+    fclose(fp);
+}
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key(){
+    int             ret = 0;
+    int             bits = 2048;
+    unsigned long   e = RSA_F4;
+    RSA             *r = NULL;
+    BIGNUM          *bne = NULL;
+    BIO             *bp_private = NULL;
+
+    bne = BN_new();
+    ret = BN_set_word(bne,e);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    r = RSA_new();
+    ret = RSA_generate_key_ex(r, bits, bne, NULL);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    bp_private = BIO_new_file(RSA_KEY, "w+");
+    ret = PEM_write_bio_RSAPrivateKey(bp_private, r, NULL, NULL, 0, NULL, NULL);
+
+    free_r(bp_private, r, bne);
+}
+
diff -rupN openssl-1.1.0f/crypto/nightgale/sub_t.h openssl/crypto/nightgale/sub_t.h
--- openssl-1.1.0f/crypto/nightgale/sub_t.h	1969-12-31 16:00:00.000000000 -0800
+++ openssl/crypto/nightgale/sub_t.h	2017-06-05 18:19:46.923137493 -0700
@@ -0,0 +1,96 @@
+#ifndef HEADER_SUB_H
+#define HEADER_SUB_H
+
+#include "pcg_variants.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define RSA_KEY "private.pem"
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+//-----------------------------------------------------------------------------
+// Set the sub table for nightgale
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s);
+void nightgale_dec_set_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Get the file length with fseek()
+//-----------------------------------------------------------------------------
+long unsigned int get_file_length(FILE *fp);
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne);
+
+//-----------------------------------------------------------------------------
+// Read binary key file
+//-----------------------------------------------------------------------------
+void read_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Output key to screen and binary file
+//-----------------------------------------------------------------------------
+void write_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void * elem1, const void * elem2);
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Generate Hash from private key file from RSA
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const char* key_file);
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key();
+
+#endif
+
diff -rupN openssl-1.1.0f/crypto/objects/obj_dat.h openssl/crypto/objects/obj_dat.h
--- openssl-1.1.0f/crypto/objects/obj_dat.h	2017-05-25 05:46:19.000000000 -0700
+++ openssl/crypto/objects/obj_dat.h	2017-06-05 18:40:22.367813692 -0700
@@ -963,7 +963,7 @@ static const unsigned char so[6765] = {
     0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x10,0x01,0x1C,  /* [ 6753] OBJ_id_ct_xml */
 };
 
-#define NUM_NID 1061
+#define NUM_NID 1062
 static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {"UNDEF", "undefined", NID_undef},
     {"rsadsi", "RSA Data Security, Inc.", NID_rsadsi, 6, &so[0]},
@@ -2026,9 +2026,10 @@ static const ASN1_OBJECT nid_objs[NUM_NI
     {"id-smime-ct-contentCollection", "id-smime-ct-contentCollection", NID_id_smime_ct_contentCollection, 11, &so[6731]},
     {"id-smime-ct-authEnvelopedData", "id-smime-ct-authEnvelopedData", NID_id_smime_ct_authEnvelopedData, 11, &so[6742]},
     {"id-ct-xml", "id-ct-xml", NID_id_ct_xml, 11, &so[6753]},
+    {"NIGHTGALE", "nightgale", NID_nightgale},
 };
 
-#define NUM_SN 1052
+#define NUM_SN 1053
 static const unsigned int sn_objs[NUM_SN] = {
      364,    /* "AD_DVCS" */
      419,    /* "AES-128-CBC" */
@@ -2179,6 +2180,7 @@ static const unsigned int sn_objs[NUM_SN
       95,    /* "MDC2" */
      911,    /* "MGF1" */
      388,    /* "Mail" */
+    1061,    /* "NIGHTGALE" */
      393,    /* "NULL" */
      404,    /* "NULL" */
       57,    /* "Netscape" */
@@ -3084,7 +3086,7 @@ static const unsigned int sn_objs[NUM_SN
      160,    /* "x509Crl" */
 };
 
-#define NUM_LN 1052
+#define NUM_LN 1053
 static const unsigned int ln_objs[NUM_LN] = {
      363,    /* "AD Time Stamping" */
      405,    /* "ANSI X9.62" */
@@ -3815,6 +3817,7 @@ static const unsigned int ln_objs[NUM_LN
      488,    /* "mobileTelephoneNumber" */
      481,    /* "nSRecord" */
      173,    /* "name" */
+    1061,    /* "nightgale" */
      681,    /* "onBasis" */
      379,    /* "org" */
       17,    /* "organizationName" */
diff -rupN openssl-1.1.0f/crypto/objects/objects.txt openssl/crypto/objects/objects.txt
--- openssl-1.1.0f/crypto/objects/objects.txt	2017-05-25 05:46:19.000000000 -0700
+++ openssl/crypto/objects/objects.txt	2017-06-05 18:23:18.406477665 -0700
@@ -861,6 +861,9 @@ mime-mhs-headings 2	: id-hex-multipart-m
 !Cname zlib-compression
 id-smime-alg 8		: ZLIB			: zlib compression
 
+#Nightgale
+            		: NIGHTGALE 		: nightgale
+
 # AES aka Rijndael
 
 !Alias csor 2 16 840 1 101 3
diff -rupN openssl-1.1.0f/crypto/objects/obj_mac.num openssl/crypto/objects/obj_mac.num
--- openssl-1.1.0f/crypto/objects/obj_mac.num	2017-05-25 05:46:19.000000000 -0700
+++ openssl/crypto/objects/obj_mac.num	2017-06-05 18:40:22.312814839 -0700
@@ -1058,3 +1058,4 @@ blake2s256		1057
 id_smime_ct_contentCollection		1058
 id_smime_ct_authEnvelopedData		1059
 id_ct_xml		1060
+nightgale		1061
diff -rupN openssl-1.1.0f/include/openssl/evp.h openssl/include/openssl/evp.h
--- openssl-1.1.0f/include/openssl/evp.h	2017-05-25 05:46:20.000000000 -0700
+++ openssl/include/openssl/evp.h	2017-06-05 18:25:47.679248838 -0700
@@ -746,6 +746,9 @@ const EVP_CIPHER *EVP_rc5_32_12_16_cfb64
 #  define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64
 const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
 # endif
+
+const EVP_CIPHER *EVP_nightgale(void);
+
 const EVP_CIPHER *EVP_aes_128_ecb(void);
 const EVP_CIPHER *EVP_aes_128_cbc(void);
 const EVP_CIPHER *EVP_aes_128_cfb1(void);
diff -rupN openssl-1.1.0f/include/openssl/nightgale.h openssl/include/openssl/nightgale.h
--- openssl-1.1.0f/include/openssl/nightgale.h	1969-12-31 16:00:00.000000000 -0800
+++ openssl/include/openssl/nightgale.h	2017-06-05 18:20:07.342682153 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HEADER_NIGHT_H
+# define HEADER_NIGHT_H
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define WORD_SIZE 8
+
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+void nightgale_enc_set_key(SUB *s);
+void nightgale_dec_set_key(SUB *s);
+
+void encrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
diff -rupN openssl-1.1.0f/include/openssl/obj_mac.h openssl/include/openssl/obj_mac.h
--- openssl-1.1.0f/include/openssl/obj_mac.h	2017-05-25 05:46:20.000000000 -0700
+++ openssl/include/openssl/obj_mac.h	2017-06-05 18:40:22.319814692 -0700
@@ -2603,6 +2603,10 @@
 #define NID_zlib_compression            125
 #define OBJ_zlib_compression            OBJ_id_smime_alg,8L
 
+#define SN_nightgale            "NIGHTGALE"
+#define LN_nightgale            "nightgale"
+#define NID_nightgale           1061
+
 #define OBJ_csor                2L,16L,840L,1L,101L,3L
 
 #define OBJ_nistAlgorithms              OBJ_csor,4L
diff -rupN openssl-1.1.0f/include/openssl/ssl.h openssl/include/openssl/ssl.h
--- openssl-1.1.0f/include/openssl/ssl.h	2017-05-25 05:46:20.000000000 -0700
+++ openssl/include/openssl/ssl.h	2017-06-05 18:29:00.029139443 -0700
@@ -112,6 +112,8 @@ extern "C" {
 # define SSL_TXT_kGOST           "kGOST"
 # define SSL_TXT_kSRP            "kSRP"
 
+# define SSL_TXT_NIGHTGALE       "NIGHTGALE"
+
 # define SSL_TXT_aRSA            "aRSA"
 # define SSL_TXT_aDSS            "aDSS"
 # define SSL_TXT_aDH             "aDH"
diff -rupN openssl-1.1.0f/include/openssl/tls1.h openssl/include/openssl/tls1.h
--- openssl-1.1.0f/include/openssl/tls1.h	2017-05-25 05:46:20.000000000 -0700
+++ openssl/include/openssl/tls1.h	2017-06-05 18:30:26.113314420 -0700
@@ -571,6 +571,9 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_T
 # define TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256              0x0300C03A
 # define TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384              0x0300C03B
 
+/* Nightingale ciphersuite */
+# define TLS1_CK_ECDHE_RSA_WITH_NIGHTGALE_SHA384         0x0300C03C
+
 /* Camellia-CBC ciphersuites from RFC6367 */
 # define TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 0x0300C072
 # define TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 0x0300C073
@@ -685,6 +688,9 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_T
 # define TLS1_TXT_PSK_WITH_NULL_SHA256                   "PSK-NULL-SHA256"
 # define TLS1_TXT_PSK_WITH_NULL_SHA384                   "PSK-NULL-SHA384"
 
+/* Nightgale ciphersuite */
+# define TLS1_TXT_ECDHE_RSA_WITH_NIGHTGALE_SHA384        "ECDHE-RSA-NIGHTGALE-SHA384"
+
 # define TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA256        "DHE-PSK-AES128-CBC-SHA256"
 # define TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA384        "DHE-PSK-AES256-CBC-SHA384"
 # define TLS1_TXT_DHE_PSK_WITH_NULL_SHA256               "DHE-PSK-NULL-SHA256"
diff -rupN openssl-1.1.0f/night_evp_test.c openssl/night_evp_test.c
--- openssl-1.1.0f/night_evp_test.c	1969-12-31 16:00:00.000000000 -0800
+++ openssl/night_evp_test.c	2017-06-05 18:33:54.705918503 -0700
@@ -0,0 +1,162 @@
+#include <openssl/conf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <string.h>
+#include <assert.h> 
+#include <sys/time.h>
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+void handleErrors(void)
+{
+  ERR_print_errors_fp(stderr);
+  abort();
+}
+
+int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *ciphertext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int ciphertext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the encryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_EncryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+  /* Provide the message to be encrypted, and obtain the encrypted output.
+   * EVP_EncryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
+    handleErrors();
+  ciphertext_len = len;
+
+
+  /* Finalise the encryption. Further ciphertext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
+  ciphertext_len += len;
+
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return ciphertext_len;
+}
+
+int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *plaintext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int plaintext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the decryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_DecryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+
+  /* Provide the message to be decrypted, and obtain the plaintext output.
+   * EVP_DecryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
+    handleErrors();
+  plaintext_len = len;
+
+  /* Finalise the decryption. Further plaintext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) handleErrors();
+  plaintext_len += len;
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return plaintext_len;
+}
+
+int main (void)
+{
+  /* Set up the key and iv. Do I need to say to not hard code these in a
+   * real application? :-)
+   */
+
+  int length = 1024*1024*1024;
+  printf("Creating 1GB random buffer...\n");
+  unsigned char* plaintext = calloc(sizeof(unsigned char), length);
+  FILE *fp;
+  fp = fopen("/dev/urandom", "r");
+  fread(plaintext, 1, length, fp);
+  fclose(fp);
+
+  /* A 256 bit key */
+  unsigned char *key = (unsigned char *)"0";
+
+  /* A 128 bit IV */
+  unsigned char *iv = (unsigned char *)"0";
+
+  /* Buffer for ciphertext. Ensure the buffer is long enough for the
+   * ciphertext which may be longer than the plaintext, dependant on the
+   * algorithm and mode
+   */
+  unsigned char *ciphertext = calloc(sizeof(unsigned char), length+8);
+
+  /* Buffer for the decrypted text */
+  unsigned char *decryptedtext = calloc(sizeof(unsigned char), length+8);
+
+  /* Initialise the library */
+  ERR_load_crypto_strings();
+  OpenSSL_add_all_algorithms();
+
+  printf("Encrypting....\n");
+  // encrypt
+  double t1;
+  t1 = mysecond();
+
+  /* Encrypt the plaintext */
+  int ciphertext_len = encrypt (plaintext, length, key, iv, ciphertext);
+  t1 = mysecond() - t1;
+  double rate = (((double)length)/1000000000.)/t1;
+
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+  printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+  /* Decrypt the ciphertext */
+  decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext);
+
+  int check;
+  check = memcmp( plaintext, decryptedtext, length ); assert(check == 0);
+  check = memcmp( plaintext, ciphertext, length ); assert(check != 0);
+
+  /* Clean up */
+  EVP_cleanup();
+  ERR_free_strings();
+
+  return 0;
+}
+
+
diff -rupN openssl-1.1.0f/night_test.c openssl/night_test.c
--- openssl-1.1.0f/night_test.c	1969-12-31 16:00:00.000000000 -0800
+++ openssl/night_test.c	2017-06-05 18:33:56.120888788 -0700
@@ -0,0 +1,70 @@
+#include <string.h>
+#include <assert.h>
+#include <openssl/nightgale.h>
+#include <stdlib.h>
+#include <sys/time.h>
+
+#define RSA_KEY "private.pem"
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+
+void system_test(){
+    printf("1GB random check\n");
+    size_t length = 1024 * 1024 * 1024;
+
+    printf("Creating 1GB random buffer...\n");
+    unsigned char *plain = calloc(sizeof(unsigned char), length);
+    unsigned char *enc = calloc(sizeof(unsigned char), length);
+    unsigned char *dec = calloc(sizeof(unsigned char), length);
+
+    FILE *fp; 
+    fp = fopen("/dev/urandom", "r");
+    fread(plain, 1, length, fp);
+    fclose(fp);
+
+    SUB s_enc;
+    nightgale_enc_set_key(&s_enc);
+
+    printf("Encrypting...\n");
+
+    double t1;
+    t1 = mysecond();
+    encrypt_night(&s_enc, length, plain, enc);
+    t1 = mysecond() - t1;
+    double rate = (((double)length)/1000000000.)/t1;
+
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+    printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+    SUB s_dec;
+    nightgale_dec_set_key(&s_dec);
+
+    decrypt_night(&s_dec, length, enc, dec);
+
+    int check = memcmp( plain, dec, length );       assert(check == 0);
+
+    check = memcmp( plain, enc, length );       assert(check != 0);
+
+    FILE *f = fopen("encrypt7.bin", "wb");
+    fwrite(enc, length, 1, f);
+    fclose(f);
+
+    free(plain);
+    free(enc);
+    free(dec);
+}
+
+
+int main(){
+    system_test();
+    return 0;
+}
+
diff -rupN openssl-1.1.0f/private.pem openssl/private.pem
--- openssl-1.1.0f/private.pem	1969-12-31 16:00:00.000000000 -0800
+++ openssl/private.pem	2017-06-05 18:43:24.872015654 -0700
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAuoEavzwVt1QFRTut/9CEmDSr31SwGzaqAw+hAaljhT3xR5iI
+25dHfpb6H20b3UQgHXIF9/Q5fG+Pm3g0VkSe0c7dOsrOVvd3DGmBlutbRv0sYvgP
+sfyMqoeYoKZVyaCbuy/XVhWen3lLXFxYn8o/7sLRj6KZGzdGQYo6hWGzHYrjKSg4
+rkO2mgxhMC2hFC9AEpWYsPLR894BnBvBTsmhp83eAoSlQW7sDb0/MWx0x7YZCrbZ
+kfZyXKN/mP5nBbQY+JOL8JD9jB07AMJ77efkkazMF5gZuugWfWGggQbAJwrqepoN
+wu1F9xcj2iUX35Vr24v7kGi1zDWW5qY87rlcKQIDAQABAoIBAQCvEHLX4QGNZVvR
+IfTxNHzSFlbiuq7XzJcHaos6cRLOxlcOWnrUjQr6I6PDDfri1ojCuv4pQmEXkeye
+BdYyyBTAYko9XpMTBRUFXJ/c1y2F1C3u9GRfMO2lQMSev6O1MIId0glyb7bGgOeh
+WbmCvCkI6GwnRHwtFNRovuSxwQSNi+1tmsVpqWCUGAQrb2N0gl7GRfx4RM4LYL+7
+lv8J/3MJoif1vFdnbjejNbYZXWj6gJPoOll7YVPZ5ZrZur9O83xeyJsEMtkrtCu2
+pXbWDbDHbFiRVfnrcIYm0hpQDWycynRT23pDWK9cEZRM57MAidFLroFToyVZFV6t
+ANYUt+o1AoGBAPREMr2rGy2yDp2zpHxa28HX3yTguGtMG0I/wL+KkywkRwX0FGe8
+ventNne+TYGMo6lr+JNq3wnaFhKzONSrUTZE4Y0VzSMjyS/feCYrZgg2z6RXstkY
+DBRtXxrb+UwWJ7KwXFhvSR9RUOlbgqtvjmxOH3n17ZQE1iL8XRBGSZd7AoGBAMN2
+l5xPevBYb3QQM9acGMpcRHm4ui5kSJ3kmS9HwADQWKhf/CfyQXXXvtMBdyNe66yv
+oAz1dnehumdFFlqHSPd5ixQWS5CbJpLfiNeXO/t8fOakDqub1DC9d2ZncYAO8aMJ
+ohxzzzgTpS09CZpd1qBQx6Ra6bB1FeM9ozg2RXerAoGBAI3EFv7lk7yNntYAMPLL
+eMekFio9EkuTvC5S+fcw4gG4fFAEPOOIM2DU/8u3cxxBF6t4sqg8Wn5JSI5J3i3v
+0A6DI7TSdmByoI1cUUs13N3fkdt72p0My9X/NDdOe/2gziFzIeVhkTrP4vnM1qXQ
+9QP+w13xUZWayP09InYTlRqJAoGAAuDLKLUO5V0X/wiCCuXvg4NKStSKgUZev1xv
+WP/gduKae5g2OUxa5GZR2/+Iho/OPpOzcp1mqipKeVzOEHUvgN1cS+ZsJGv0bHM4
+K5yBeJmDqU2/HY3E2RbhHDPnuu/9ZN4ucebOpU+8vebJLmm1UFUAK45fJIcE1HzC
+24AJE9MCgYBEYNwn/A4NP1dr1VtVfYN0vkUB6rjNjqZUL7opBagKflJYqcHNKxIY
+IZQwk3/6KbHEoO7GdL0ucbFtFd9siB37PtiJyPabmLncl4YA4yXHyHDQFV5QiU3C
+rTtlilEPmBByJbcGSQCGaLt4im1VQNwCn2i63cHXi88oYBH9KCAFyQ==
+-----END RSA PRIVATE KEY-----
diff -rupN openssl-1.1.0f/ssl/s3_lib.c openssl/ssl/s3_lib.c
--- openssl-1.1.0f/ssl/s3_lib.c	2017-05-25 05:46:20.000000000 -0700
+++ openssl/ssl/s3_lib.c	2017-06-05 18:32:06.561193458 -0700
@@ -1142,6 +1142,21 @@ static SSL_CIPHER ssl3_ciphers[] = {
      256,
      256,
      },
+    {
+     1,
+     TLS1_TXT_ECDHE_RSA_WITH_NIGHTGALE_SHA384,
+     TLS1_CK_ECDHE_RSA_WITH_NIGHTGALE_SHA384,
+     SSL_kECDHE,
+     SSL_aRSA,
+     SSL_NIGHTGALE,
+     SSL_SHA384,
+     TLS1_VERSION, TLS1_2_VERSION,
+     DTLS1_VERSION, DTLS1_2_VERSION,
+     SSL_HIGH | SSL_FIPS,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     512,
+     512,
+     },
 #endif                          /* OPENSSL_NO_EC */
 
 #ifndef OPENSSL_NO_PSK
diff -rupN openssl-1.1.0f/ssl/ssl_ciph.c openssl/ssl/ssl_ciph.c
--- openssl-1.1.0f/ssl/ssl_ciph.c	2017-05-25 05:46:20.000000000 -0700
+++ openssl/ssl/ssl_ciph.c	2017-06-05 18:27:49.007651163 -0700
@@ -68,7 +68,8 @@
 #define SSL_ENC_AES256CCM8_IDX  17
 #define SSL_ENC_GOST8912_IDX    18
 #define SSL_ENC_CHACHA_IDX      19
-#define SSL_ENC_NUM_IDX         20
+#define SSL_ENC_NIGHTGALE       20
+#define SSL_ENC_NUM_IDX         21
 
 /* NB: make sure indices in these tables match values above */
 
@@ -99,6 +100,7 @@ static const ssl_cipher_table ssl_cipher
     {SSL_AES256CCM8, NID_aes_256_ccm}, /* SSL_ENC_AES256CCM8_IDX 17 */
     {SSL_eGOST2814789CNT12, NID_gost89_cnt_12}, /* SSL_ENC_GOST8912_IDX */
     {SSL_CHACHA20POLY1305, NID_chacha20_poly1305},
+    {SSL_NIGHTGALE, NID_nightgale},
 };
 
 static const EVP_CIPHER *ssl_cipher_methods[SSL_ENC_NUM_IDX] = {
@@ -297,6 +299,7 @@ static const SSL_CIPHER cipher_aliases[]
     {0, SSL_TXT_CAMELLIA256, 0, 0, 0, SSL_CAMELLIA256},
     {0, SSL_TXT_CAMELLIA, 0, 0, 0, SSL_CAMELLIA},
     {0, SSL_TXT_CHACHA20, 0, 0, 0, SSL_CHACHA20},
+    {0, SSL_TXT_NIGHTGALE, 0, 0, 0, SSL_NIGHTGALE},
 
     /* MAC aliases */
     {0, SSL_TXT_MD5, 0, 0, 0, 0, SSL_MD5},
@@ -1667,6 +1670,9 @@ char *SSL_CIPHER_description(const SSL_C
     case SSL_CHACHA20POLY1305:
         enc = "CHACHA20/POLY1305(256)";
         break;
+    case SSL_NIGHTGALE:
+    	enc = "NIGHTGALE";
+    	break;
     default:
         enc = "unknown";
         break;
diff -rupN openssl-1.1.0f/ssl/ssl_init.c openssl/ssl/ssl_init.c
--- openssl-1.1.0f/ssl/ssl_init.c	2017-05-25 05:46:20.000000000 -0700
+++ openssl/ssl/ssl_init.c	2017-06-05 18:28:19.285005973 -0700
@@ -28,6 +28,9 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_bas
     fprintf(stderr, "OPENSSL_INIT: ossl_init_ssl_base: "
             "Adding SSL ciphers and digests\n");
 #endif
+
+    EVP_add_cipher(EVP_nightgale());
+
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cbc());
     EVP_add_cipher(EVP_des_ede3_cbc());
diff -rupN openssl-1.1.0f/ssl/ssl_locl.h openssl/ssl/ssl_locl.h
--- openssl-1.1.0f/ssl/ssl_locl.h	2017-05-25 05:46:20.000000000 -0700
+++ openssl/ssl/ssl_locl.h	2017-06-05 18:33:12.057814712 -0700
@@ -268,6 +268,8 @@
 # define SSL_eGOST2814789CNT12   0x00040000U
 # define SSL_CHACHA20POLY1305    0x00080000U
 
+# define SSL_NIGHTGALE           0x00100000U
+
 # define SSL_AESGCM              (SSL_AES128GCM | SSL_AES256GCM)
 # define SSL_AESCCM              (SSL_AES128CCM | SSL_AES256CCM | SSL_AES128CCM8 | SSL_AES256CCM8)
 # define SSL_AES                 (SSL_AES128|SSL_AES256|SSL_AESGCM|SSL_AESCCM)
diff -rupN openssl-1.1.0f/util/libcrypto.num openssl/util/libcrypto.num
--- openssl-1.1.0f/util/libcrypto.num	2017-05-25 05:46:21.000000000 -0700
+++ openssl/util/libcrypto.num	2017-06-05 18:40:23.623787526 -0700
@@ -4230,3 +4230,8 @@ UINT32_it
 UINT32_it                               4214	1_1_0f	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ZINT64_it                               4215	1_1_0f	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 ZINT64_it                               4215	1_1_0f	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+EVP_nightgale                           4216	1_1_0f	EXIST::FUNCTION:
+nightgale_enc_set_key                   4217	1_1_0f	EXIST::FUNCTION:
+nightgale_dec_set_key                   4218	1_1_0f	EXIST::FUNCTION:
+encrypt_night                           4219	1_1_0f	EXIST::FUNCTION:
+decrypt_night                           4220	1_1_0f	EXIST::FUNCTION:
diff -rupN openssl-1.1.0f/util/mkdef.pl openssl/util/mkdef.pl
--- openssl-1.1.0f/util/mkdef.pl	2017-05-25 05:46:21.000000000 -0700
+++ openssl/util/mkdef.pl	2017-06-05 18:24:33.985837732 -0700
@@ -274,6 +274,8 @@ $crypto.=" include/openssl/lhash.h" ; #
 $crypto.=" include/openssl/conf.h";
 $crypto.=" include/openssl/txt_db.h";
 
+$crypto.=" include/openssl/nightgale.h";
+
 $crypto.=" include/openssl/evp.h" ; # unless $no_evp;
 $crypto.=" include/openssl/objects.h";
 $crypto.=" include/openssl/pem.h";
