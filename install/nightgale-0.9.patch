diff -rupN openssl-master/compile_night_test.sh openssl/compile_night_test.sh
--- openssl-master/compile_night_test.sh	1969-12-31 19:00:00.000000000 -0500
+++ openssl/compile_night_test.sh	2017-04-20 07:26:11.908166237 -0400
@@ -0,0 +1,8 @@
+rm -f night_test
+rm -f night_evp_test
+./config && make update && make -j 2 && \
+gcc -I./include -L. -Wextra -Wall -o night_evp_test night_evp_test.c -lcrypto && \
+gcc -I./include -L. -Wextra -Wall -o night_test night_test.c -lcrypto && \
+LD_LIBRARY_PATH=. ./night_test && \
+LD_LIBRARY_PATH=. ./night_evp_test && \
+LD_LIBRARY_PATH=. ./apps/openssl speed -elapsed -evp nightgale
diff -rupN openssl-master/Configure openssl/Configure
--- openssl-master/Configure	2017-04-17 15:10:27.000000000 -0400
+++ openssl/Configure	2017-04-20 07:26:11.908166237 -0400
@@ -310,7 +310,7 @@ $config{dirs} = [ "crypto", "ssl", "engi
 # crypto/ subdirectories to build
 $config{sdirs} = [
     "objects",
-    "md2", "md4", "md5", "sha", "mdc2", "hmac", "ripemd", "whrlpool", "poly1305", "blake2", "siphash",
+    "md2", "md4", "nightgale", "md5", "sha", "mdc2", "hmac", "ripemd", "whrlpool", "poly1305", "blake2", "siphash",
     "des", "aes", "rc2", "rc4", "rc5", "idea", "aria", "bf", "cast", "camellia", "seed", "chacha", "modes",
     "bn", "ec", "rsa", "dsa", "dh", "dso", "engine",
     "buffer", "bio", "stack", "lhash", "rand", "err",
diff -rupN openssl-master/crypto/evp/build.info openssl/crypto/evp/build.info
--- openssl-master/crypto/evp/build.info	2017-04-17 15:10:27.000000000 -0400
+++ openssl/crypto/evp/build.info	2017-04-20 07:26:11.636166237 -0400
@@ -3,7 +3,7 @@ SOURCE[../../libcrypto]=\
         encode.c digest.c evp_enc.c evp_key.c evp_cnf.c \
         e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
         e_rc4.c e_aes.c names.c e_seed.c e_aria.c \
-        e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
+        e_night.c e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
         m_null.c m_md2.c m_md4.c m_md5.c m_sha1.c m_wp.c \
         m_md5_sha1.c m_mdc2.c m_ripemd.c \
         p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
diff -rupN openssl-master/crypto/evp/c_allc.c openssl/crypto/evp/c_allc.c
--- openssl-master/crypto/evp/c_allc.c	2017-04-17 15:10:27.000000000 -0400
+++ openssl/crypto/evp/c_allc.c	2017-04-20 07:26:11.648166237 -0400
@@ -16,6 +16,8 @@
 
 void openssl_add_all_ciphers_int(void)
 {
+    EVP_add_cipher(EVP_nightgale());
+    EVP_add_cipher_alias(SN_nightgale, "nightgale");
 
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cfb());
diff -rupN openssl-master/crypto/evp/e_night.c openssl/crypto/evp/e_night.c
--- openssl-master/crypto/evp/e_night.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/evp/e_night.c	2017-04-20 07:26:11.648166237 -0400
@@ -0,0 +1,57 @@
+#include <stdio.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/nightgale.h>
+#include "internal/cryptlib.h"
+#include "internal/evp_int.h"
+
+typedef struct {
+	SUB s;
+	union {
+		void (*cipher) (SUB *s, size_t len, const unsigned char *in,
+                                    unsigned char *out);
+	} stream;
+} EVP_NIGHT_KEY;
+
+#define data(ctx) ((EVP_NIGHT_KEY *)EVP_CIPHER_CTX_get_cipher_data(ctx))
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+				const unsigned char *iv, int enc);
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl);
+
+static const EVP_CIPHER nightgale_cipher = {
+	NID_nightgale,
+	1, 256, 0, // block_size, key size, iv size 
+	0,
+	nightgale_init_key, // function pointer to key init
+	nightgale_c, // function pointer to cipher operation
+	NULL, // clean up function pointer
+	sizeof(EVP_NIGHT_KEY), // size of ctx
+	NULL,
+	NULL,
+	NULL,
+	NULL	
+};
+
+const EVP_CIPHER *EVP_nightgale(void)
+{
+	return (&nightgale_cipher);
+}
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                                const unsigned char *iv, int enc)
+{
+	enc ? nightgale_enc_set_key(&data(ctx)->s, key) : 
+			nightgale_dec_set_key(&data(ctx)->s, key);
+	data(ctx)->stream.cipher = enc ? encrypt_night : decrypt_night;
+	return 1;
+}
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl)
+{
+	(*data(ctx)->stream.cipher) (&data(ctx)->s, inl, in, out);
+	return 1;
+}
diff -rupN openssl-master/crypto/nightgale/build.info openssl/crypto/nightgale/build.info
--- openssl-master/crypto/nightgale/build.info	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/build.info	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,3 @@
+LIBS=../../libcrypto
+SOURCE[../../libcrypto]=\
+sub_t.c nightgale_c.c
diff -rupN openssl-master/crypto/nightgale/nightgale_c.c openssl/crypto/nightgale/nightgale_c.c
--- openssl-master/crypto/nightgale/nightgale_c.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/nightgale_c.c	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,98 @@
+#include "nightgale_c.h"
+
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char* in, 
+                    unsigned char * out){
+
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)out;
+    uint64_t *plain_text = (uint64_t *)in;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word;
+
+    // Encrypt buffers
+    root = anchor;
+    for(int i = 0; i < word_count; ++i){
+        decimal_word = root ^ plain_text[i] ^ hamming_mask;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int k = 0; k < WORD_SIZE; ++k) pre_sub[k] = s->sub[(int)pre_sub[k]];
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        enc_message[i] = decimal_word ^ key ^ anchor;
+        root = decimal_word;
+    }
+}
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                                unsigned char *out){
+    
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)in;
+    uint64_t *dec_message = (uint64_t *)out;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word, pre_sub_decimal_word;
+
+    // Decrypt here
+    root = anchor;
+    for(int i = 0; i < word_count; ++i) {
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        decimal_word = enc_message[i] ^ key ^ anchor;
+	pre_sub_decimal_word = decimal_word;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int j = 0; j < WORD_SIZE; ++j) pre_sub[j] = s->reverse_sub[(int)pre_sub[j]];
+        dec_message[i] = root ^ decimal_word ^ hamming_mask;
+        root = pre_sub_decimal_word;
+    }
+}
+
diff -rupN openssl-master/crypto/nightgale/nightgale_c.h openssl/crypto/nightgale/nightgale_c.h
--- openssl-master/crypto/nightgale/nightgale_c.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/nightgale_c.h	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,32 @@
+#ifndef HEADER_NIGHTGALE_H
+#define HEADER_NIGHTGALE_H
+
+#include "pcg_variants.h"
+#include "sub_t.h"
+
+#define WORD_SIZE 8
+#define MASK 0xfc00000000000000
+
+//-----------------------------------------------------------------------------
+// Encrypt
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char *in, 
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Decrypt
+//-----------------------------------------------------------------------------
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Anchor rotation based off the last 6 bits of the key
+//-----------------------------------------------------------------------------
+inline uint64_t rotr64 (uint64_t n, unsigned int c){
+    const unsigned int mask = (CHAR_BIT*sizeof(n)-1);
+    c &= mask;
+    return (n>>c) | (n<<( (-c)&mask ));
+}
+
+#endif
+
diff -rupN openssl-master/crypto/nightgale/pcg_variants.h openssl/crypto/nightgale/pcg_variants.h
--- openssl-master/crypto/nightgale/pcg_variants.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/pcg_variants.h	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,351 @@
+/*
+ * PCG Random Number Generation for C.
+ *
+ * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * For additional information about the PCG random number generation scheme,
+ * including its license and other licensing options, visit
+ *
+ *     http://www.pcg-random.org
+ */
+
+/*
+ * This code is derived from the canonical C++ PCG implementation, which
+ * has many additional features and is preferable if you can use C++ in
+ * your project.
+ *
+ * Much of the derivation was performed mechanically.  In particular, the
+ * output functions were generated by compiling the C++ output functions
+ * into LLVM bitcode and then transforming that using the LLVM C backend
+ * (from https://github.com/draperlaboratory/llvm-cbe), and then
+ * postprocessing and hand editing the output.
+ *
+ * Much of the remaining code was generated by C-preprocessor metaprogramming.
+
+pcg-advance-16.c pcg-advance-16.c\
+    pcg-advance-8.c pcg-global-32.c pcg-global-32.c\
+    pcg-global-32.c pcg-output-32.c pcg-output-8.c\
+    pcg-output-8.c pcg-rngs-16.c pcg-rngs-16.c\
+    pcg-rngs-8.c
+ 
+ */
+
+#ifndef PCG_VARIANTS_H_INCLUDED
+#define PCG_VARIANTS_H_INCLUDED 1
+
+#include <inttypes.h>
+
+#if __SIZEOF_INT128__
+    typedef __uint128_t pcg128_t;
+    #define PCG_128BIT_CONSTANT(high,low) \
+            ((((pcg128_t)high) << 64) + low)
+    #define PCG_HAS_128BIT_OPS 1
+#endif
+
+#if __GNUC_GNU_INLINE__  &&  !defined(__cplusplus)
+    #error Nonstandard GNU inlining semanatics. Compile with -std=c99 or better.
+    // We could instead use macros PCG_INLINE and PCG_EXTERN_INLINE
+    // but better to just reject ancient C code.
+#endif
+
+/*
+ * Rotate helper functions.
+ */
+
+inline uint8_t pcg_rotr_8(uint8_t value, unsigned int rot)
+{
+/* Unfortunately, clang is kinda pathetic when  it comes to properly
+ * recognizing idiomatic rotate code, so for clang we actually provide
+ * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss.
+ */
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorb   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 7));
+#endif
+}
+
+inline uint16_t pcg_rotr_16(uint16_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorw   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 15));
+#endif
+}
+
+inline uint32_t pcg_rotr_32(uint32_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorl   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 31));
+#endif
+}
+
+inline uint64_t pcg_rotr_64(uint64_t value, unsigned int rot)
+{
+#if 0 && PCG_USE_INLINE_ASM && __clang__ && __x86_64__
+    // For whatever reason, clang actually *does* generator rotq by
+    // itself, so we don't need this code.
+    asm ("rorq   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 63));
+#endif
+}
+
+/*
+ * Output functions.  These are the core of the PCG generation scheme.
+ */
+
+
+
+
+
+
+// XSL RR (only defined for >= 64 bits)
+
+inline uint64_t pcg_output_xsl_rr_128_64(pcg128_t state)//////////////////////////////////////////////////////////////////////////////
+{
+    return pcg_rotr_64(((uint64_t)(state >> 64u)) ^ (uint64_t)state,
+                       state >> 122u);
+}
+
+
+#define PCG_DEFAULT_MULTIPLIER_8   141U
+#define PCG_DEFAULT_MULTIPLIER_16  12829U
+#define PCG_DEFAULT_MULTIPLIER_32  747796405U
+#define PCG_DEFAULT_MULTIPLIER_64  6364136223846793005ULL
+
+#define PCG_DEFAULT_INCREMENT_8    77U
+#define PCG_DEFAULT_INCREMENT_16   47989U
+#define PCG_DEFAULT_INCREMENT_32   2891336453U
+#define PCG_DEFAULT_INCREMENT_64   1442695040888963407ULL
+
+#define PCG_DEFAULT_MULTIPLIER_128 \
+        PCG_128BIT_CONSTANT(2549297995355413924ULL,4865540595714422341ULL)
+#define PCG_DEFAULT_INCREMENT_128  \
+        PCG_128BIT_CONSTANT(6364136223846793005ULL,1442695040888963407ULL)
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG_STATE_ONESEQ_8_INITIALIZER      { 0xd7U }
+#define PCG_STATE_ONESEQ_16_INITIALIZER     { 0x20dfU }
+#define PCG_STATE_ONESEQ_32_INITIALIZER     { 0x46b56677U }
+#define PCG_STATE_ONESEQ_64_INITIALIZER     { 0x4d595df4d0f33173ULL }
+#define PCG_STATE_ONESEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0xb8dc10e158a92392ULL, 0x98046df007ec0a53ULL) }
+
+#define PCG_STATE_UNIQUE_8_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG_STATE_UNIQUE_16_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG_STATE_UNIQUE_32_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG_STATE_UNIQUE_64_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG_STATE_UNIQUE_128_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG_STATE_MCG_8_INITIALIZER         { 0xe5U }
+#define PCG_STATE_MCG_16_INITIALIZER        { 0xa5e5U }
+#define PCG_STATE_MCG_32_INITIALIZER        { 0xd15ea5e5U }
+#define PCG_STATE_MCG_64_INITIALIZER        { 0xcafef00dd15ea5e5ULL }
+#define PCG_STATE_MCG_128_INITIALIZER                                          \
+    { PCG_128BIT_CONSTANT(0x0000000000000000ULL, 0xcafef00dd15ea5e5ULL) }
+
+#define PCG_STATE_SETSEQ_8_INITIALIZER      { 0x9bU, 0xdbU }
+#define PCG_STATE_SETSEQ_16_INITIALIZER     { 0xe39bU, 0x5bdbU }
+#define PCG_STATE_SETSEQ_32_INITIALIZER     { 0xec02d89bU, 0x94b95bdbU }
+#define PCG_STATE_SETSEQ_64_INITIALIZER                                        \
+    { 0x853c49e6748fea9bULL, 0xda3e39cb94b95bdbULL }
+#define PCG_STATE_SETSEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0x979c9a98d8462005ULL, 0x7d3e9cb6cfe0549bULL),       \
+      PCG_128BIT_CONSTANT(0x0000000000000001ULL, 0xda3e39cb94b95bdbULL) }
+
+/* Representations for the oneseq, mcg, and unique variants */
+
+struct pcg_state_8 {
+    uint8_t state;
+};
+
+struct pcg_state_16 {
+    uint16_t state;
+};
+
+struct pcg_state_32 {
+    uint32_t state;
+};
+
+struct pcg_state_64 {
+    uint64_t state;
+};
+
+struct pcg_state_128 {
+    pcg128_t state;
+};
+
+/* Representations setseq variants */
+
+struct pcg_state_setseq_8 {
+    uint8_t state;
+    uint8_t inc;
+};
+
+struct pcg_state_setseq_16 {
+    uint16_t state;
+    uint16_t inc;
+};
+
+struct pcg_state_setseq_32 {
+    uint32_t state;
+    uint32_t inc;
+};
+
+struct pcg_state_setseq_64 {
+    uint64_t state;
+    uint64_t inc;
+};
+
+struct pcg_state_setseq_128 {
+    pcg128_t state;
+    pcg128_t inc;
+};
+
+
+/* Functions to advance the underlying LCG, one version for each size and
+ * each style.  These functions are considered semi-private.  There is rarely
+ * a good reason to call them directly.
+ */
+
+
+
+/* Functions to seed the RNG state, one version for each size and each
+ * style.  Unlike the step functions, regular users can and should call
+ * these functions.
+ */
+
+
+
+
+
+inline void pcg_setseq_128_step_r(struct pcg_state_setseq_128* rng)/////////////////////////////////////////////////////////////////////////////
+{
+    rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128 + rng->inc;
+}
+
+inline void pcg_setseq_128_srandom_r(struct pcg_state_setseq_128* rng,////////////////////////////////////////////////////////////////////////////
+                                     pcg128_t initstate, pcg128_t initseq)
+{
+    rng->state = 0U;
+    rng->inc = (initseq << 1u) | 1u;
+    pcg_setseq_128_step_r(rng);
+    rng->state += initstate;
+    pcg_setseq_128_step_r(rng);
+}
+
+/* Now, finally we create each of the individual generators. We provide
+ * a random_r function that provides a random number of the appropriate
+ * type (using the full range of the type) and a boundedrand_r version
+ * that provides
+ *
+ * Implementation notes for boundedrand_r:
+ *
+ *     To avoid bias, we need to make the range of the RNG a multiple of
+ *     bound, which we do by dropping output less than a threshold.
+ *     Let's consider a 32-bit case...  A naive scheme to calculate the
+ *     threshold would be to do
+ *
+ *         uint32_t threshold = 0x100000000ull % bound;
+ *
+ *     but 64-bit div/mod is slower than 32-bit div/mod (especially on
+ *     32-bit platforms).  In essence, we do
+ *
+ *         uint32_t threshold = (0x100000000ull-bound) % bound;
+ *
+ *     because this version will calculate the same modulus, but the LHS
+ *     value is less than 2^32.
+ *
+ *     (Note that using modulo is only wise for good RNGs, poorer RNGs
+ *     such as raw LCGs do better using a technique based on division.)
+ *     Empricical tests show that division is preferable to modulus for
+ *     reducting the range of an RNG.  It's faster, and sometimes it can
+ *     even be statistically prefereable.
+ */
+
+/* Generation functions for XSH RS */
+
+
+inline uint64_t
+pcg_setseq_128_xsl_rr_64_random_r(struct pcg_state_setseq_128* rng)///////////////////////////////////////////////////////////////////////
+{
+    pcg_setseq_128_step_r(rng);
+    return pcg_output_xsl_rr_128_64(rng->state);
+}
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_64      pcg32_random_t;
+typedef struct pcg_state_64             pcg32s_random_t;
+typedef struct pcg_state_64             pcg32u_random_t;
+typedef struct pcg_state_64             pcg32f_random_t;
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_128     pcg64_random_t;
+typedef struct pcg_state_128            pcg64s_random_t;
+typedef struct pcg_state_128            pcg64u_random_t;
+typedef struct pcg_state_128            pcg64f_random_t;
+//// random_r
+#define pcg64_random_r                  pcg_setseq_128_xsl_rr_64_random_r
+
+//// srandom_r
+#define pcg64_srandom_r                 pcg_setseq_128_srandom_r
+
+
+ uint64_t pcg64_random();
+ void     pcg64_srandom(pcg128_t seed, pcg128_t seq);
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG32_INITIALIZER       PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG32U_INITIALIZER      PCG_STATE_UNIQUE_64_INITIALIZER
+#define PCG32S_INITIALIZER      PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG32F_INITIALIZER      PCG_STATE_MCG_64_INITIALIZER
+
+#define PCG64_INITIALIZER       PCG_STATE_SETSEQ_128_INITIALIZER
+#define PCG64U_INITIALIZER      PCG_STATE_UNIQUE_128_INITIALIZER
+#define PCG64S_INITIALIZER      PCG_STATE_ONESEQ_128_INITIALIZER
+#define PCG64F_INITIALIZER      PCG_STATE_MCG_128_INITIALIZER
+
+#define PCG8SI_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG16SI_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG32SI_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG64SI_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG128SI_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG8I_INITIALIZER       PCG_STATE_SETSEQ_8_INITIALIZER
+#define PCG16I_INITIALIZER      PCG_STATE_SETSEQ_16_INITIALIZER
+#define PCG32I_INITIALIZER      PCG_STATE_SETSEQ_32_INITIALIZER
+#define PCG64I_INITIALIZER      PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG128I_INITIALIZER     PCG_STATE_SETSEQ_128_INITIALIZER
+
+#endif // PCG_VARIANTS_H_INCLUDED
+
diff -rupN openssl-master/crypto/nightgale/sub_t.c openssl/crypto/nightgale/sub_t.c
--- openssl-master/crypto/nightgale/sub_t.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/sub_t.c	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,158 @@
+#include "sub_t.h"
+
+//-----------------------------------------------------------------------------
+void nightgale_dec_set_key(SUB *s, unsigned char *key){
+    generate_hash(s, key);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s, unsigned char *key){
+    generate_key(s);
+    generate_hash(s, key);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+size_t get_file_length(FILE *fp) {
+    fseek(fp, 0L, SEEK_CUR);
+    long unsigned int mypos = ftell(fp);
+    fseek(fp, 0L, SEEK_END);
+    long unsigned int filesize = ftell(fp);
+    fseek(fp, mypos, SEEK_SET);
+    return filesize;
+ }
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne){
+    BIO_free_all(bp_private);
+    RSA_free(r);
+    BN_free(bne);
+}
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void *elem1, const void *elem2){
+    indexes *i1, *i2;
+    i1 = (indexes *)elem1;
+    i2 = (indexes *)elem2;
+    return i1->value - i2->value;
+}
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s){
+    indexes knuth_sort[SUB_SIZE];
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        knuth_sort[i].index = i+1;
+        knuth_sort[i].value = s->sub_rands[i];
+    }
+
+    qsort(knuth_sort, SUB_SIZE, sizeof(indexes), cmp);
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        s->sub[i] = (unsigned char)knuth_sort[i].index;
+        s->reverse_sub[(unsigned char)knuth_sort[i].index] = i;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s){
+    pcg64_random_t rng1, rng2, rng3, rng4;
+    pcg128_t round = 5;
+    pcg128_t s1, s2, s3, s4;
+
+    void *temp;
+
+    temp = s->seed1;
+    s1 = *(pcg128_t *)temp;
+    
+    temp = s->seed2;
+    s2 = *(pcg128_t *)temp;
+
+    temp = s->seed3;
+    s3 = *(pcg128_t *)temp;
+
+    temp = s->seed4;
+    s4 = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng1, s1, round);
+    pcg64_srandom_r(&rng2, s2, round);
+    pcg64_srandom_r(&rng3, s3, round);
+    pcg64_srandom_r(&rng4, s4, round);
+
+    for(int i = 0; i < 64; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng1);
+    }
+    for(int i = 64; i < 128; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng2);
+    }
+    for(int i = 128; i < 192; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng3);
+    }
+    for(int i = 192; i < 256; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng4);
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s){
+    memcpy(s->seed1, s->hash, SEED_SIZE);
+    memcpy(s->seed2, s->hash + SEED_SIZE, SEED_SIZE);
+    memcpy(s->seed3, s->hash + SEED_SIZE*2, SEED_SIZE);
+    memcpy(s->seed4, s->hash + SEED_SIZE*3, SEED_SIZE);
+}
+
+//-----------------------------------------------------------------------------
+// Generate Hash from private key file from RSA
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const unsigned char* key){
+
+    SHA512(key, 255, s->hash);
+    SHA256(s->hash, SHA512_DIGEST_LENGTH, s->digest);
+}
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key(){
+    int             ret = 0;
+    int             bits = 2048;
+    unsigned long   e = RSA_F4;
+    RSA             *r = NULL;
+    BIGNUM          *bne = NULL;
+    BIO             *bp_private = NULL;
+
+    bne = BN_new();
+    ret = BN_set_word(bne,e);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    r = RSA_new();
+    ret = RSA_generate_key_ex(r, bits, bne, NULL);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    bp_private = BIO_new_file(RSA_KEY, "w+");
+    ret = PEM_write_bio_RSAPrivateKey(bp_private, r, NULL, NULL, 0, NULL, NULL);
+
+    free_r(bp_private, r, bne);
+}
+
diff -rupN openssl-master/crypto/nightgale/sub_t.h openssl/crypto/nightgale/sub_t.h
--- openssl-master/crypto/nightgale/sub_t.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/sub_t.h	2017-04-20 07:26:11.688166237 -0400
@@ -0,0 +1,96 @@
+#ifndef HEADER_SUB_H
+#define HEADER_SUB_H
+
+#include "pcg_variants.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define RSA_KEY "private.pem"
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+//-----------------------------------------------------------------------------
+// Set the sub table for nightgale
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s, unsigned char *key);
+void nightgale_dec_set_key(SUB *s, unsigned char *key);
+
+//-----------------------------------------------------------------------------
+// Get the file length with fseek()
+//-----------------------------------------------------------------------------
+long unsigned int get_file_length(FILE *fp);
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne);
+
+//-----------------------------------------------------------------------------
+// Read binary key file
+//-----------------------------------------------------------------------------
+void read_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Output key to screen and binary file
+//-----------------------------------------------------------------------------
+void write_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void * elem1, const void * elem2);
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Generate Hash from key
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const unsigned char* key);
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key();
+
+#endif
+
diff -rupN openssl-master/crypto/objects/obj_dat.h openssl/crypto/objects/obj_dat.h
--- openssl-master/crypto/objects/obj_dat.h	2017-04-17 15:10:27.000000000 -0400
+++ openssl/crypto/objects/obj_dat.h	2017-04-20 07:26:11.664166237 -0400
@@ -978,7 +978,7 @@ static const unsigned char so[6900] = {
     0x2A,0x83,0x1A,0x8C,0x9A,0x6E,0x01,0x01,0x0F,  /* [ 6890] OBJ_aria_256_ctr */
 };
 
-#define NUM_NID 1086
+#define NUM_NID 1087
 static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {"UNDEF", "undefined", NID_undef},
     {"rsadsi", "RSA Data Security, Inc.", NID_rsadsi, 6, &so[0]},
@@ -2066,9 +2066,10 @@ static const ASN1_OBJECT nid_objs[NUM_NI
     {"ARIA-128-CFB8", "aria-128-cfb8", NID_aria_128_cfb8},
     {"ARIA-192-CFB8", "aria-192-cfb8", NID_aria_192_cfb8},
     {"ARIA-256-CFB8", "aria-256-cfb8", NID_aria_256_cfb8},
+    {"NIGHTGALE", "nightgale", NID_nightgale},
 };
 
-#define NUM_SN 1077
+#define NUM_SN 1078
 static const unsigned int sn_objs[NUM_SN] = {
      364,    /* "AD_DVCS" */
      419,    /* "AES-128-CBC" */
@@ -2242,6 +2243,7 @@ static const unsigned int sn_objs[NUM_SN
       95,    /* "MDC2" */
      911,    /* "MGF1" */
      388,    /* "Mail" */
+    1086,    /* "NIGHTGALE" */
      393,    /* "NULL" */
      404,    /* "NULL" */
       57,    /* "Netscape" */
@@ -3149,7 +3151,7 @@ static const unsigned int sn_objs[NUM_SN
      160,    /* "x509Crl" */
 };
 
-#define NUM_LN 1077
+#define NUM_LN 1078
 static const unsigned int ln_objs[NUM_LN] = {
      363,    /* "AD Time Stamping" */
      405,    /* "ANSI X9.62" */
@@ -3903,6 +3905,7 @@ static const unsigned int ln_objs[NUM_LN
      488,    /* "mobileTelephoneNumber" */
      481,    /* "nSRecord" */
      173,    /* "name" */
+    1086,    /* "nightgale" */
      681,    /* "onBasis" */
      379,    /* "org" */
       17,    /* "organizationName" */
diff -rupN openssl-master/crypto/objects/objects.txt openssl/crypto/objects/objects.txt
--- openssl-master/crypto/objects/objects.txt	2017-04-17 15:10:27.000000000 -0400
+++ openssl/crypto/objects/objects.txt	2017-04-20 07:26:11.664166237 -0400
@@ -861,6 +861,9 @@ mime-mhs-headings 2	: id-hex-multipart-m
 !Cname zlib-compression
 id-smime-alg 8		: ZLIB			: zlib compression
 
+#Nightgale
+			: NIGHTGALE 		: nightgale
+
 # AES aka Rijndael
 
 !Alias csor 2 16 840 1 101 3
diff -rupN openssl-master/crypto/objects/obj_mac.num openssl/crypto/objects/obj_mac.num
--- openssl-master/crypto/objects/obj_mac.num	2017-04-17 15:10:27.000000000 -0400
+++ openssl/crypto/objects/obj_mac.num	2017-04-20 07:26:11.664166237 -0400
@@ -1083,3 +1083,6 @@ aria_256_cfb1		1082
 aria_128_cfb8		1083
 aria_192_cfb8		1084
 aria_256_cfb8		1085
+nightgale		1086
+nightgale512		1087
+nightgale128		1088
Binary files openssl-master/encrypt7.bin and openssl/encrypt7.bin differ
diff -rupN openssl-master/include/openssl/evp.h openssl/include/openssl/evp.h
--- openssl-master/include/openssl/evp.h	2017-04-17 15:10:27.000000000 -0400
+++ openssl/include/openssl/evp.h	2017-04-20 07:26:11.888166237 -0400
@@ -664,6 +664,9 @@ __owur int BIO_set_cipher(BIO *b, const
                           const unsigned char *i, int enc);
 
 const EVP_MD *EVP_md_null(void);
+
+const EVP_CIPHER *EVP_nightgale(void);
+
 # ifndef OPENSSL_NO_MD2
 const EVP_MD *EVP_md2(void);
 # endif
diff -rupN openssl-master/include/openssl/nightgale.h openssl/include/openssl/nightgale.h
--- openssl-master/include/openssl/nightgale.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/include/openssl/nightgale.h	2017-04-20 07:26:11.888166237 -0400
@@ -0,0 +1,70 @@
+/*
+ * Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HEADER_NIGHT_H
+# define HEADER_NIGHT_H
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define WORD_SIZE 8
+
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+void nightgale_enc_set_key(SUB *s, const unsigned char *key);
+void nightgale_dec_set_key(SUB *s, const unsigned char *key);
+
+void encrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+void encrypt_night_128 (SUB *s, const unsigned char *in,
+                    unsigned char *out);
+
+
+void decrypt_night_128 (SUB *s, const unsigned char *in,
+                    unsigned char *out);
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
diff -rupN openssl-master/include/openssl/obj_mac.h openssl/include/openssl/obj_mac.h
--- openssl-master/include/openssl/obj_mac.h	2017-04-17 15:10:27.000000000 -0400
+++ openssl/include/openssl/obj_mac.h	2017-04-20 07:26:11.888166237 -0400
@@ -2603,6 +2603,10 @@
 #define NID_zlib_compression            125
 #define OBJ_zlib_compression            OBJ_id_smime_alg,8L
 
+#define SN_nightgale            "NIGHTGALE"
+#define LN_nightgale            "nightgale"
+#define NID_nightgale           1086
+
 #define OBJ_csor                2L,16L,840L,1L,101L,3L
 
 #define OBJ_nistAlgorithms              OBJ_csor,4L
Binary files openssl-master/night_evp_test and openssl/night_evp_test differ
diff -rupN openssl-master/night_evp_test.c openssl/night_evp_test.c
--- openssl-master/night_evp_test.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/night_evp_test.c	2017-04-20 07:26:11.908166237 -0400
@@ -0,0 +1,163 @@
+#include <openssl/conf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <string.h>
+#include <assert.h> 
+#include <sys/time.h>
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+void handleErrors(void)
+{
+  ERR_print_errors_fp(stderr);
+  abort();
+}
+
+int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *ciphertext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int ciphertext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the encryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_EncryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+  /* Provide the message to be encrypted, and obtain the encrypted output.
+   * EVP_EncryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
+    handleErrors();
+  ciphertext_len = len;
+
+
+  /* Finalise the encryption. Further ciphertext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
+  ciphertext_len += len;
+
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return ciphertext_len;
+}
+
+int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *plaintext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int plaintext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the decryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_DecryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+
+  /* Provide the message to be decrypted, and obtain the plaintext output.
+   * EVP_DecryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
+    handleErrors();
+  plaintext_len = len;
+
+  /* Finalise the decryption. Further plaintext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) handleErrors();
+  plaintext_len += len;
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return plaintext_len;
+}
+
+int main (void)
+{
+  /* Set up the key and iv. Do I need to say to not hard code these in a
+   * real application? :-)
+   */
+
+  int length = 1024*1024*1024;
+  printf("Creating 1GB random buffer...\n");
+  unsigned char* plaintext = calloc(sizeof(unsigned char), length);
+  FILE *fp;
+  fp = fopen("/dev/urandom", "r");
+  fread(plaintext, 1, length, fp);
+  fclose(fp);
+
+  /* A 256 bit key */
+  unsigned char key[256]; //(unsigned char *)"0";
+  for(int i = 0; i < 256; ++i) key[i] = i;
+
+  /* A 128 bit IV */
+  unsigned char *iv = (unsigned char *)"0";
+
+  /* Buffer for ciphertext. Ensure the buffer is long enough for the
+   * ciphertext which may be longer than the plaintext, dependant on the
+   * algorithm and mode
+   */
+  unsigned char *ciphertext = calloc(sizeof(unsigned char), length+8);
+
+  /* Buffer for the decrypted text */
+  unsigned char *decryptedtext = calloc(sizeof(unsigned char), length+8);
+
+  /* Initialise the library */
+  ERR_load_crypto_strings();
+  OpenSSL_add_all_algorithms();
+
+  printf("Encrypting....\n");
+  // encrypt
+  double t1;
+  t1 = mysecond();
+
+  /* Encrypt the plaintext */
+  int ciphertext_len = encrypt (plaintext, length, key, iv, ciphertext);
+  t1 = mysecond() - t1;
+  double rate = (((double)length)/1000000000.)/t1;
+
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+  printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+  /* Decrypt the ciphertext */
+  decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext);
+
+  int check;
+  check = memcmp( plaintext, decryptedtext, length ); assert(check == 0);
+  check = memcmp( plaintext, ciphertext, length ); assert(check != 0);
+
+  /* Clean up */
+  EVP_cleanup();
+  ERR_free_strings();
+
+  return 0;
+}
+
+
Binary files openssl-master/night_test and openssl/night_test differ
diff -rupN openssl-master/night_test.c openssl/night_test.c
--- openssl-master/night_test.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/night_test.c	2017-04-20 07:26:11.892166237 -0400
@@ -0,0 +1,70 @@
+#include <string.h>
+#include <assert.h>
+#include <openssl/nightgale.h>
+#include <stdlib.h>
+#include <sys/time.h>
+
+#define RSA_KEY "private.pem"
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+
+void system_test(){
+
+    unsigned char key[256];
+    for(int i = 0; i < 256; ++i) key[i] = i;
+
+    printf("1GB random check\n");
+    size_t length = 1024 * 1024 * 1024;
+
+    printf("Creating 1GB random buffer...\n");
+    unsigned char *plain = calloc(sizeof(unsigned char), length);
+    unsigned char *enc = calloc(sizeof(unsigned char), length);
+    unsigned char *dec = calloc(sizeof(unsigned char), length);
+
+    FILE *fp; 
+    fp = fopen("/dev/urandom", "r");
+    fread(plain, 1, length, fp);
+    fclose(fp);
+
+    SUB s_enc;
+    nightgale_enc_set_key(&s_enc, key);
+
+    printf("Encrypting...\n");
+
+    double t1;
+    t1 = mysecond();
+    encrypt_night(&s_enc, length, plain, enc);
+    t1 = mysecond() - t1;
+    double rate = (((double)length)/1000000000.)/t1;
+
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+    printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+    SUB s_dec;
+    nightgale_dec_set_key(&s_dec, key);
+
+    decrypt_night(&s_dec, length, enc, dec);
+
+    int check = memcmp( plain, dec, length );       assert(check == 0);
+
+    check = memcmp( plain, enc, length );       assert(check != 0);
+
+    free(plain);
+    free(enc);
+    free(dec);
+}
+
+
+int main(){
+    system_test();
+    return 0;
+}
+
diff -rupN openssl-master/private.pem openssl/private.pem
--- openssl-master/private.pem	1969-12-31 19:00:00.000000000 -0500
+++ openssl/private.pem	2017-04-20 07:26:11.908166237 -0400
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEA3m6Tvp3Wdl0nQzuNF7s+9hIlnc2cQHgfKorV2Myf0AkIbzPL
+KtINU4FKBftm1tGfx9tFOnmxfANTotT7l37nB0PMZMLTFkT+9cHNBELIsSfoh3RS
+AAZCh3Iv/9qqaTc3kvK3iuZJC0LP10xm/HbP1CH8W44dmenAtTzgQa9phAMagalv
+zsoSHS7Ry6drFnPeGb1ibHAZaWf2gYiaxmuhgyLNlI1A1wSoKYr9c+M6oIxGARoz
+ozZnbtImC/BwbKyvoKcEhjh2KliBcfYNnw36Vz799mAoiNbuQOqXgKGS5K08/2Hv
+SiteUVf/OOu1xkw0pB/IUIz2M+7Mtzt/SjHp/wIDAQABAoIBADDUT4TR+4mia4Mb
+6J5kEa9NToq0329br2PUdJuSWCcARKS81wYAdMJ3KHvls67G9++U2D69BlR2Gn8t
+iEm6pxb2MEGSb2p9HQdwUwRzcMFLRIWv6Gxu813umFDvfOd6Iq4UsGxCn5hkQ2I9
+OIKFxpwIFfE3YpIuOYrP4V8qFdzPtKpmHg4YKA3DjNJ1U81FtumojrECRsJiCZjV
+gKF6qx0mZVtRKEeLt9gwLdNynOxRPqYdIDbOo19PuMTh3YY5tMPv7HzhxGFdOPDC
+AyUVPFd5FB7yHsxTiU2PbNLGmYrfhDC9cQ8KUxAZL2xX1Jf9Fk9X6Z1BIYhuOvhl
+XRX2FqkCgYEA/JOa/I8ubnIXbJ6FdwNnigkzsK4iKdqVa9vwxw1xiuhvD9ox1KOw
+mZKuQ7BcTJK8T4xUThHbx/kxiNv9Kdq9vNWRylWMxa6rtGtksz2ZAG8Yezo9Vcyk
+RKGHeRXmOJsiKpnD37ITAYMAn6jsnTSiyUc7ZNxXdcBzZ5tDDXLR0zsCgYEA4XJg
+FIu+eh8B7OhWx1kKObSNmkx+33pzvIHqJp/Yv/glc9pge7jV6NUaylGV1aRc8aU6
+y+R4vqKbylrpQCCHdafSMLotS4lLWzwA54UOPqrcaBRM21bkQHEFcfklbxRyBFpg
+1fykL0gnTYcl/pNN9Cd9Jj16y3W+/JO8If6bkA0CgYAYqFhTG69OvPioc/lXmw96
+nFddgkJ3j41S0E/7Psa85uAgzg5bUfelpno4xXjdSN31bh+01217YkqBr+hRM7ee
+PcNT23I4wkqk/G8CSJstPatILHFcdPP8d0CAg7DMCekV+5jxt7K/TQi8jYM7/a1+
+tOOJfzFSn40kqjWrlHADjQKBgQCHRHL1oOtGprgnBziaH4iNGxIjVGaDfBtZLbHq
+Ptp0RFVkb9CYK0zdiI+seMsoBphlvLfMgmcYKsTC4000VtAv/eOVrP9kZRo7wYLh
+ZuonG6lnIVcD+9yz9ZxIyC53uZK3neqgOhfg7q/2SnK3jnalWdQzT4wP67QOJC4r
+T3LTOQKBgDauDVRbtzpjeSPbM8SP6E9RjOhXeT/WIcrDMNuYyckKLzdrT3x+a6ip
+ysXp9PuzXHsTckcbd30Fp6cO6bNb31doIef/RqGyCj6rVQWiGNqEoKSW1RYNO0NR
+ESS0RYBzhoEkOHNbEW+vFHA+Qg1R7ET7SY8EuI4tYZTrdUdwlmr6
+-----END RSA PRIVATE KEY-----
diff -rupN openssl-master/ssl/ssl_init.c openssl/ssl/ssl_init.c
--- openssl-master/ssl/ssl_init.c	2017-04-17 15:10:27.000000000 -0400
+++ openssl/ssl/ssl_init.c	2017-04-20 07:26:11.892166237 -0400
@@ -28,6 +28,9 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_bas
     fprintf(stderr, "OPENSSL_INIT: ossl_init_ssl_base: "
             "Adding SSL ciphers and digests\n");
 #endif
+
+    EVP_add_cipher(EVP_nightgale());
+
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cbc());
     EVP_add_cipher(EVP_des_ede3_cbc());
diff -rupN openssl-master/util/libcrypto.num openssl/util/libcrypto.num
--- openssl-master/util/libcrypto.num	2017-04-17 15:10:27.000000000 -0400
+++ openssl/util/libcrypto.num	2017-04-20 07:26:12.716166237 -0400
@@ -4270,3 +4270,10 @@ UINT32_it
 UINT32_it                               4214	1_1_0f	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ZINT64_it                               4215	1_1_0f	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 ZINT64_it                               4215	1_1_0f	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+nightgale_enc_set_key                   4216	1_1_1	EXIST::FUNCTION:
+EVP_nightgale                           4217	1_1_1	EXIST::FUNCTION:
+nightgale_dec_set_key                   4218	1_1_1	EXIST::FUNCTION:
+encrypt_night                           4219	1_1_1	EXIST::FUNCTION:
+decrypt_night                           4220	1_1_1	EXIST::FUNCTION:
+decrypt_night_128                       4221	1_1_1	EXIST::FUNCTION:
+encrypt_night_128                       4222	1_1_1	EXIST::FUNCTION:
diff -rupN openssl-master/util/mkdef.pl openssl/util/mkdef.pl
--- openssl-master/util/mkdef.pl	2017-04-17 15:10:27.000000000 -0400
+++ openssl/util/mkdef.pl	2017-04-20 07:26:12.716166237 -0400
@@ -250,6 +250,8 @@ $crypto.=" include/openssl/aes.h" ; # un
 $crypto.=" include/openssl/camellia.h" ; # unless $no_camellia;
 $crypto.=" include/openssl/seed.h"; # unless $no_seed;
 
+$crypto.=" include/openssl/nightgale.h";
+
 $crypto.=" include/openssl/bn.h";
 $crypto.=" include/openssl/rsa.h" ; # unless $no_rsa;
 $crypto.=" include/openssl/dsa.h" ; # unless $no_dsa;
diff -rupN openssl-master/util/mkdef.pl.orig openssl/util/mkdef.pl.orig
--- openssl-master/util/mkdef.pl.orig	1969-12-31 19:00:00.000000000 -0500
+++ openssl/util/mkdef.pl.orig	2017-04-20 07:26:12.716166237 -0400
@@ -0,0 +1,1680 @@
+#! /usr/bin/env perl
+# Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://www.openssl.org/source/license.html
+
+#
+# generate a .def file
+#
+# It does this by parsing the header files and looking for the
+# prototyped functions: it then prunes the output.
+#
+# Intermediary files are created, call libcrypto.num and libssl.num,
+# The format of these files is:
+#
+#	routine-name	nnnn	vers	info
+#
+# The "nnnn" and "vers" fields are the numeric id and version for the symbol
+# respectively. The "info" part is actually a colon-separated string of fields
+# with the following meaning:
+#
+#	existence:platform:kind:algorithms
+#
+# - "existence" can be "EXIST" or "NOEXIST" depending on if the symbol is
+#   found somewhere in the source,
+# - "platforms" is empty if it exists on all platforms, otherwise it contains
+#   comma-separated list of the platform, just as they are if the symbol exists
+#   for those platforms, or prepended with a "!" if not.  This helps resolve
+#   symbol name variants for platforms where the names are too long for the
+#   compiler or linker, or if the systems is case insensitive and there is a
+#   clash, or the symbol is implemented differently (see
+#   EXPORT_VAR_AS_FUNCTION).  This script assumes renaming of symbols is found
+#   in the file crypto/symhacks.h.
+#   The semantics for the platforms is that every item is checked against the
+#   environment.  For the negative items ("!FOO"), if any of them is false
+#   (i.e. "FOO" is true) in the environment, the corresponding symbol can't be
+#   used.  For the positive itms, if all of them are false in the environment,
+#   the corresponding symbol can't be used.  Any combination of positive and
+#   negative items are possible, and of course leave room for some redundancy.
+# - "kind" is "FUNCTION" or "VARIABLE".  The meaning of that is obvious.
+# - "algorithms" is a comma-separated list of algorithm names.  This helps
+#   exclude symbols that are part of an algorithm that some user wants to
+#   exclude.
+#
+
+use lib ".";
+use configdata;
+use File::Spec::Functions;
+
+my $debug=0;
+
+my $crypto_num= catfile($config{sourcedir},"util","libcrypto.num");
+my $ssl_num=    catfile($config{sourcedir},"util","libssl.num");
+my $libname;
+
+my $do_update = 0;
+my $do_rewrite = 1;
+my $do_crypto = 0;
+my $do_ssl = 0;
+my $do_ctest = 0;
+my $do_ctestall = 0;
+my $do_checkexist = 0;
+
+my $VMS=0;
+my $W32=0;
+my $NT=0;
+my $linux=0;
+# Set this to make typesafe STACK definitions appear in DEF
+my $safe_stack_def = 0;
+
+my @known_platforms = ( "__FreeBSD__", "PERL5",
+			"EXPORT_VAR_AS_FUNCTION", "ZLIB", "_WIN32"
+			);
+my @known_ossl_platforms = ( "VMS", "WIN32", "WINNT", "OS2" );
+my @known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
+			 "CAST", "MD2", "MD4", "MD5", "SHA", "SHA0", "SHA1",
+			 "SHA256", "SHA512", "RMD160",
+			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "EC2M",
+			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST", "ARIA",
+                         "SCRYPT", "CHACHA", "POLY1305", "BLAKE2",
+			 "SIPHASH",
+			 # EC_NISTP_64_GCC_128
+			 "EC_NISTP_64_GCC_128",
+			 # Envelope "algorithms"
+			 "EVP", "X509", "ASN1_TYPEDEFS",
+			 # Helper "algorithms"
+			 "BIO", "COMP", "BUFFER", "LHASH", "STACK", "ERR",
+			 "LOCKING",
+			 # External "algorithms"
+			 "FP_API", "STDIO", "SOCK", "DGRAM",
+                         "CRYPTO_MDEBUG",
+			 # Engines
+                         "STATIC_ENGINE", "ENGINE", "HW", "GMP",
+			 # Entropy Gathering
+			 "EGD",
+			 # Certificate Transparency
+			 "CT",
+			 # RFC3779
+			 "RFC3779",
+			 # TLS
+			 "PSK", "SRP", "HEARTBEATS",
+			 # CMS
+			 "CMS",
+                         "OCSP",
+			 # CryptoAPI Engine
+			 "CAPIENG",
+			 # SSL methods
+			 "SSL3_METHOD", "TLS1_METHOD", "TLS1_1_METHOD", "TLS1_2_METHOD", "DTLS1_METHOD", "DTLS1_2_METHOD",
+			 # NEXTPROTONEG
+			 "NEXTPROTONEG",
+			 # Deprecated functions
+			 "DEPRECATEDIN_0_9_8",
+			 "DEPRECATEDIN_1_0_0",
+			 "DEPRECATEDIN_1_1_0",
+			 "DEPRECATEDIN_1_2_0",
+			 # SCTP
+		 	 "SCTP",
+			 # SRTP
+			 "SRTP",
+			 # SSL TRACE
+		 	 "SSL_TRACE",
+			 # Unit testing
+		 	 "UNIT_TEST",
+			 # User Interface
+			 "UI",
+			 #
+			 "TS",
+			 # OCB mode
+			 "OCB",
+			 "CMAC",
+                         # APPLINK (win build feature?)
+                         "APPLINK"
+                     );
+
+my %disabled_algorithms;
+
+foreach (@known_algorithms) {
+    $disabled_algorithms{$_} = 0;
+}
+# disabled by default
+$disabled_algorithms{"STATIC_ENGINE"} = 1;
+
+my $apiv = sprintf "%x%02x%02x", split(/\./, $config{api});
+foreach (keys %disabled_algorithms) {
+	if (/^DEPRECATEDIN_(\d+)_(\d+)_(\d+)$/) {
+		my $depv = sprintf "%x%02x%02x", $1, $2, $3;
+		$disabled_algorithms{$_} = 1 if $apiv ge $depv;
+	}
+}
+
+my $zlib;
+
+foreach (@ARGV, split(/ /, $config{options}))
+	{
+	$debug=1 if $_ eq "debug";
+	$W32=1 if $_ eq "32";
+	die "win16 not supported" if $_ eq "16";
+	if($_ eq "NT") {
+		$W32 = 1;
+		$NT = 1;
+	}
+	if ($_ eq "linux") {
+		$linux=1;
+	}
+	$VMS=1 if $_ eq "VMS";
+	if ($_ eq "zlib" || $_ eq "enable-zlib" || $_ eq "zlib-dynamic"
+			 || $_ eq "enable-zlib-dynamic") {
+		$zlib = 1;
+	}
+
+	$do_ssl=1 if $_ eq "libssl";
+	if ($_ eq "ssl") {
+		$do_ssl=1;
+		$libname=$_
+	}
+	$do_crypto=1 if $_ eq "libcrypto";
+	if ($_ eq "crypto") {
+		$do_crypto=1;
+		$libname=$_;
+	}
+	$do_update=1 if $_ eq "update";
+	$do_rewrite=1 if $_ eq "rewrite";
+	$do_ctest=1 if $_ eq "ctest";
+	$do_ctestall=1 if $_ eq "ctestall";
+	$do_checkexist=1 if $_ eq "exist";
+	if (/^(enable|disable|no)-(.*)$/) {
+		my $alg = uc $2;
+		$alg =~ tr/-/_/;
+		if (exists $disabled_algorithms{$alg}) {
+			$disabled_algorithms{$alg} = $1 eq "enable" ? 0 : 1;
+		}
+	}
+
+	}
+
+if (!$libname) {
+	if ($do_ssl) {
+		$libname="LIBSSL";
+	}
+	if ($do_crypto) {
+		$libname="LIBCRYPTO";
+	}
+}
+
+# If no platform is given, assume WIN32
+if ($W32 + $VMS + $linux == 0) {
+	$W32 = 1;
+}
+die "Please, only one platform at a time"
+    if ($W32 + $VMS + $linux > 1);
+
+if (!$do_ssl && !$do_crypto)
+	{
+	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT | OS2 | linux | VMS ]\n";
+	exit(1);
+	}
+
+%ssl_list=&load_numbers($ssl_num);
+$max_ssl = $max_num;
+%crypto_list=&load_numbers($crypto_num);
+$max_crypto = $max_num;
+
+my $ssl="include/openssl/ssl.h";
+$ssl.=" include/openssl/tls1.h";
+$ssl.=" include/openssl/srtp.h";
+
+# We use headers found in include/openssl and include/internal only.
+# The latter is needed so libssl.so/.dll/.exe can link properly.
+my $crypto ="include/openssl/crypto.h";
+$crypto.=" include/internal/o_dir.h";
+$crypto.=" include/internal/o_str.h";
+$crypto.=" include/internal/err.h";
+$crypto.=" include/openssl/des.h" ; # unless $no_des;
+$crypto.=" include/openssl/idea.h" ; # unless $no_idea;
+$crypto.=" include/openssl/rc4.h" ; # unless $no_rc4;
+$crypto.=" include/openssl/rc5.h" ; # unless $no_rc5;
+$crypto.=" include/openssl/rc2.h" ; # unless $no_rc2;
+$crypto.=" include/openssl/blowfish.h" ; # unless $no_bf;
+$crypto.=" include/openssl/cast.h" ; # unless $no_cast;
+$crypto.=" include/openssl/whrlpool.h" ;
+$crypto.=" include/openssl/md2.h" ; # unless $no_md2;
+$crypto.=" include/openssl/md4.h" ; # unless $no_md4;
+$crypto.=" include/openssl/md5.h" ; # unless $no_md5;
+$crypto.=" include/openssl/mdc2.h" ; # unless $no_mdc2;
+$crypto.=" include/openssl/sha.h" ; # unless $no_sha;
+$crypto.=" include/openssl/ripemd.h" ; # unless $no_ripemd;
+$crypto.=" include/openssl/aes.h" ; # unless $no_aes;
+$crypto.=" include/openssl/camellia.h" ; # unless $no_camellia;
+$crypto.=" include/openssl/seed.h"; # unless $no_seed;
+
+$crypto.=" include/openssl/bn.h";
+$crypto.=" include/openssl/rsa.h" ; # unless $no_rsa;
+$crypto.=" include/openssl/dsa.h" ; # unless $no_dsa;
+$crypto.=" include/openssl/dh.h" ; # unless $no_dh;
+$crypto.=" include/openssl/ec.h" ; # unless $no_ec;
+$crypto.=" include/openssl/hmac.h" ; # unless $no_hmac;
+$crypto.=" include/openssl/cmac.h" ;
+
+$crypto.=" include/openssl/engine.h"; # unless $no_engine;
+$crypto.=" include/openssl/stack.h" ; # unless $no_stack;
+$crypto.=" include/openssl/buffer.h" ; # unless $no_buffer;
+$crypto.=" include/openssl/bio.h" ; # unless $no_bio;
+$crypto.=" include/internal/dso.h" ; # unless $no_dso;
+$crypto.=" include/openssl/lhash.h" ; # unless $no_lhash;
+$crypto.=" include/openssl/conf.h";
+$crypto.=" include/openssl/txt_db.h";
+
+$crypto.=" include/openssl/evp.h" ; # unless $no_evp;
+$crypto.=" include/openssl/objects.h";
+$crypto.=" include/openssl/pem.h";
+#$crypto.=" include/openssl/meth.h";
+$crypto.=" include/openssl/asn1.h";
+$crypto.=" include/openssl/asn1t.h";
+$crypto.=" include/openssl/err.h" ; # unless $no_err;
+$crypto.=" include/openssl/pkcs7.h";
+$crypto.=" include/openssl/pkcs12.h";
+$crypto.=" include/openssl/x509.h";
+$crypto.=" include/openssl/x509_vfy.h";
+$crypto.=" include/openssl/x509v3.h";
+$crypto.=" include/openssl/ts.h";
+$crypto.=" include/openssl/rand.h";
+$crypto.=" include/openssl/comp.h" ; # unless $no_comp;
+$crypto.=" include/openssl/ocsp.h";
+$crypto.=" include/openssl/ui.h";
+#$crypto.=" include/openssl/store.h";
+$crypto.=" include/openssl/cms.h";
+$crypto.=" include/openssl/srp.h";
+$crypto.=" include/openssl/modes.h";
+$crypto.=" include/openssl/async.h";
+$crypto.=" include/openssl/ct.h";
+$crypto.=" include/openssl/kdf.h";
+
+my $symhacks="include/openssl/symhacks.h";
+
+my @ssl_symbols = &do_defs("LIBSSL", $ssl, $symhacks);
+my @crypto_symbols = &do_defs("LIBCRYPTO", $crypto, $symhacks);
+
+if ($do_update) {
+
+if ($do_ssl == 1) {
+
+	&maybe_add_info("LIBSSL",*ssl_list,@ssl_symbols);
+	if ($do_rewrite == 1) {
+		open(OUT, ">$ssl_num");
+		&rewrite_numbers(*OUT,"LIBSSL",*ssl_list,@ssl_symbols);
+	} else {
+		open(OUT, ">>$ssl_num");
+	}
+	&update_numbers(*OUT,"LIBSSL",*ssl_list,$max_ssl,@ssl_symbols);
+	close OUT;
+}
+
+if($do_crypto == 1) {
+
+	&maybe_add_info("LIBCRYPTO",*crypto_list,@crypto_symbols);
+	if ($do_rewrite == 1) {
+		open(OUT, ">$crypto_num");
+		&rewrite_numbers(*OUT,"LIBCRYPTO",*crypto_list,@crypto_symbols);
+	} else {
+		open(OUT, ">>$crypto_num");
+	}
+	&update_numbers(*OUT,"LIBCRYPTO",*crypto_list,$max_crypto,@crypto_symbols);
+	close OUT;
+}
+
+} elsif ($do_checkexist) {
+	&check_existing(*ssl_list, @ssl_symbols)
+		if $do_ssl == 1;
+	&check_existing(*crypto_list, @crypto_symbols)
+		if $do_crypto == 1;
+} elsif ($do_ctest || $do_ctestall) {
+
+	print <<"EOF";
+
+/* Test file to check all DEF file symbols are present by trying
+ * to link to all of them. This is *not* intended to be run!
+ */
+
+int main()
+{
+EOF
+	&print_test_file(*STDOUT,"LIBSSL",*ssl_list,$do_ctestall,@ssl_symbols)
+		if $do_ssl == 1;
+
+	&print_test_file(*STDOUT,"LIBCRYPTO",*crypto_list,$do_ctestall,@crypto_symbols)
+		if $do_crypto == 1;
+
+	print "}\n";
+
+} else {
+
+	&print_def_file(*STDOUT,$libname,*ssl_list,@ssl_symbols)
+		if $do_ssl == 1;
+
+	&print_def_file(*STDOUT,$libname,*crypto_list,@crypto_symbols)
+		if $do_crypto == 1;
+
+}
+
+
+sub do_defs
+{
+	my($name,$files,$symhacksfile)=@_;
+	my $file;
+	my @ret;
+	my %syms;
+	my %platform;		# For anything undefined, we assume ""
+	my %kind;		# For anything undefined, we assume "FUNCTION"
+	my %algorithm;		# For anything undefined, we assume ""
+	my %variant;
+	my %variant_cnt;	# To be able to allocate "name{n}" if "name"
+				# is the same name as the original.
+	my $cpp;
+	my %unknown_algorithms = ();
+	my $parens = 0;
+
+	foreach $file (split(/\s+/,$symhacksfile." ".$files))
+		{
+		my $fn = catfile($config{sourcedir},$file);
+		print STDERR "DEBUG: starting on $fn:\n" if $debug;
+		open(IN,"<$fn") || die "unable to open $fn:$!\n";
+		my $line = "", my $def= "";
+		my %tag = (
+			(map { $_ => 0 } @known_platforms),
+			(map { "OPENSSL_SYS_".$_ => 0 } @known_ossl_platforms),
+			(map { "OPENSSL_NO_".$_ => 0 } @known_algorithms),
+			(map { "OPENSSL_USE_".$_ => 0 } @known_algorithms),
+			(grep /^DEPRECATED_/, @known_algorithms),
+			NOPROTO		=> 0,
+			PERL5		=> 0,
+			_WINDLL		=> 0,
+			CONST_STRICT	=> 0,
+			TRUE		=> 1,
+		);
+		my $symhacking = $file eq $symhacksfile;
+		my @current_platforms = ();
+		my @current_algorithms = ();
+
+		# params: symbol, alias, platforms, kind
+		# The reason to put this subroutine in a variable is that
+		# it will otherwise create it's own, unshared, version of
+		# %tag and %variant...
+		my $make_variant = sub
+		{
+			my ($s, $a, $p, $k) = @_;
+			my ($a1, $a2);
+
+			print STDERR "DEBUG: make_variant: Entered with ",$s,", ",$a,", ",(defined($p)?$p:""),", ",(defined($k)?$k:""),"\n" if $debug;
+			if (defined($p))
+			{
+				$a1 = join(",",$p,
+					   grep(!/^$/,
+						map { $tag{$_} == 1 ? $_ : "" }
+						@known_platforms));
+			}
+			else
+			{
+				$a1 = join(",",
+					   grep(!/^$/,
+						map { $tag{$_} == 1 ? $_ : "" }
+						@known_platforms));
+			}
+			$a2 = join(",",
+				   grep(!/^$/,
+					map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ : "" }
+					@known_ossl_platforms));
+			print STDERR "DEBUG: make_variant: a1 = $a1; a2 = $a2\n" if $debug;
+			if ($a1 eq "") { $a1 = $a2; }
+			elsif ($a1 ne "" && $a2 ne "") { $a1 .= ",".$a2; }
+			if ($a eq $s)
+			{
+				if (!defined($variant_cnt{$s}))
+				{
+					$variant_cnt{$s} = 0;
+				}
+				$variant_cnt{$s}++;
+				$a .= "{$variant_cnt{$s}}";
+			}
+			my $toadd = $a.":".$a1.(defined($k)?":".$k:"");
+			my $togrep = $s.'(\{[0-9]+\})?:'.$a1.(defined($k)?":".$k:"");
+			if (!grep(/^$togrep$/,
+				  split(/;/, defined($variant{$s})?$variant{$s}:""))) {
+				if (defined($variant{$s})) { $variant{$s} .= ";"; }
+				$variant{$s} .= $toadd;
+			}
+			print STDERR "DEBUG: make_variant: Exit with variant of ",$s," = ",$variant{$s},"\n" if $debug;
+		};
+
+		print STDERR "DEBUG: parsing ----------\n" if $debug;
+		while(<IN>) {
+			if($parens > 0) {
+				#Inside a DEPRECATEDIN
+				$stored_multiline .= $_;
+				$stored_multiline =~ s|\R$||; # Better chomp
+				print STDERR "DEBUG: Continuing multiline DEPRECATEDIN: $stored_multiline\n" if $debug;
+				$parens = count_parens($stored_multiline);
+				if ($parens == 0) {
+					$def .= do_deprecated($stored_multiline,
+							\@current_platforms,
+							\@current_algorithms);
+				}
+				next;
+			}
+			if (/\/\* Error codes for the \w+ functions\. \*\//)
+				{
+				undef @tag;
+				last;
+				}
+			if ($line ne '') {
+				$_ = $line . $_;
+				$line = '';
+			}
+
+			if (/\\$/) {
+				$line = $`; # keep what was before the backslash
+				next;
+			}
+
+			if(/\/\*/) {
+				if (not /\*\//) {	# multiline comment...
+					$line = $_;	# ... just accumulate
+					next;
+				} else {
+					s/\/\*.*?\*\///gs;# wipe it
+				}
+			}
+
+			if ($cpp) {
+				$cpp++ if /^#\s*if/;
+				$cpp-- if /^#\s*endif/;
+				next;
+			}
+			if (/^#.*ifdef.*cplusplus/) {
+				$cpp = 1;
+				next;
+			}
+
+			s/{[^{}]*}//gs;                      # ignore {} blocks
+			print STDERR "DEBUG: \$def=\"$def\"\n" if $debug && $def ne "";
+			print STDERR "DEBUG: \$_=\"$_\"\n" if $debug;
+			if (/^\#\s*if\s+OPENSSL_API_COMPAT\s*(\S)\s*(0x[0-9a-fA-F]{8})L\s*$/) {
+				my $op = $1;
+				my $v = hex($2);
+				if ($op ne '<' && $op ne '>=') {
+				    die "$file unacceptable operator $op: $_\n";
+				}
+				my ($one, $major, $minor) =
+				    ( ($v >> 28) & 0xf,
+				      ($v >> 20) & 0xff,
+				      ($v >> 12) & 0xff );
+				my $t = "DEPRECATEDIN_${one}_${major}_${minor}";
+				push(@tag,"-");
+				push(@tag,$t);
+				$tag{$t}=($op eq '<' ? 1 : -1);
+				print STDERR "DEBUG: $file: found tag $t = $tag{$t}\n" if $debug;
+			} elsif (/^\#\s*ifndef\s+(.*)/) {
+				push(@tag,"-");
+				push(@tag,$1);
+				$tag{$1}=-1;
+				print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
+			} elsif (/^\#\s*if\s+!defined\(([^\)]+)\)/) {
+				push(@tag,"-");
+				if (/^\#\s*if\s+(!defined\(([^\)]+)\)(\s+\&\&\s+!defined\(([^\)]+)\))*)$/) {
+					my $tmp_1 = $1;
+					my $tmp_;
+					foreach $tmp_ (split '\&\&',$tmp_1) {
+						$tmp_ =~ /!defined\(([^\)]+)\)/;
+						print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
+						push(@tag,$1);
+						$tag{$1}=-1;
+					}
+				} else {
+					print STDERR "Warning: $file: complicated expression: $_" if $debug; # because it is O...
+					print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
+					push(@tag,$1);
+					$tag{$1}=-1;
+				}
+			} elsif (/^\#\s*ifdef\s+(\S*)/) {
+				push(@tag,"-");
+				push(@tag,$1);
+				$tag{$1}=1;
+				print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
+			} elsif (/^\#\s*if\s+defined\(([^\)]+)\)/) {
+				push(@tag,"-");
+				if (/^\#\s*if\s+(defined\(([^\)]+)\)(\s+\|\|\s+defined\(([^\)]+)\))*)$/) {
+					my $tmp_1 = $1;
+					my $tmp_;
+					foreach $tmp_ (split '\|\|',$tmp_1) {
+						$tmp_ =~ /defined\(([^\)]+)\)/;
+						print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
+						push(@tag,$1);
+						$tag{$1}=1;
+					}
+				} else {
+					print STDERR "Warning: $file: complicated expression: $_\n" if $debug; # because it is O...
+					print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
+					push(@tag,$1);
+					$tag{$1}=1;
+				}
+			} elsif (/^\#\s*error\s+(\w+) is disabled\./) {
+				my $tag_i = $#tag;
+				while($tag[$tag_i] ne "-") {
+					if ($tag[$tag_i] eq "OPENSSL_NO_".$1) {
+						$tag{$tag[$tag_i]}=2;
+						print STDERR "DEBUG: $file: chaged tag $1 = 2\n" if $debug;
+					}
+					$tag_i--;
+				}
+			} elsif (/^\#\s*endif/) {
+				my $tag_i = $#tag;
+				while($tag_i > 0 && $tag[$tag_i] ne "-") {
+					my $t=$tag[$tag_i];
+					print STDERR "DEBUG: \$t=\"$t\"\n" if $debug;
+					if ($tag{$t}==2) {
+						$tag{$t}=-1;
+					} else {
+						$tag{$t}=0;
+					}
+					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
+					pop(@tag);
+					if ($t =~ /^OPENSSL_NO_([A-Z0-9_]+)$/) {
+						$t=$1;
+					} elsif($t =~ /^OPENSSL_USE_([A-Z0-9_]+)$/) {
+						$t=$1;
+					} else {
+						$t="";
+					}
+					if ($t ne ""
+					    && !grep(/^$t$/, @known_algorithms)) {
+						$unknown_algorithms{$t} = 1;
+						#print STDERR "DEBUG: Added as unknown algorithm: $t\n" if $debug;
+					}
+					$tag_i--;
+				}
+				pop(@tag);
+			} elsif (/^\#\s*else/) {
+				my $tag_i = $#tag;
+				die "$file unmatched else\n" if $tag_i < 0;
+				while($tag[$tag_i] ne "-") {
+					my $t=$tag[$tag_i];
+					$tag{$t}= -$tag{$t};
+					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
+					$tag_i--;
+				}
+			} elsif (/^\#\s*if\s+1/) {
+				push(@tag,"-");
+				# Dummy tag
+				push(@tag,"TRUE");
+				$tag{"TRUE"}=1;
+				print STDERR "DEBUG: $file: found 1\n" if $debug;
+			} elsif (/^\#\s*if\s+0/) {
+				push(@tag,"-");
+				# Dummy tag
+				push(@tag,"TRUE");
+				$tag{"TRUE"}=-1;
+				print STDERR "DEBUG: $file: found 0\n" if $debug;
+			} elsif (/^\#\s*if\s+/) {
+				#Some other unrecognized "if" style
+				push(@tag,"-");
+			} elsif (/^\#\s*define\s+(\w+)\s+(\w+)/
+				 && $symhacking && $tag{'TRUE'} != -1) {
+				# This is for aliasing.  When we find an alias,
+				# we have to invert
+				&$make_variant($1,$2);
+				print STDERR "DEBUG: $file: defined $1 = $2\n" if $debug;
+			}
+			if (/^\#/) {
+				@current_platforms =
+				    grep(!/^$/,
+					 map { $tag{$_} == 1 ? $_ :
+						   $tag{$_} == -1 ? "!".$_  : "" }
+					 @known_platforms);
+				push @current_platforms
+				    , grep(!/^$/,
+					   map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ :
+						     $tag{"OPENSSL_SYS_".$_} == -1 ? "!".$_  : "" }
+					   @known_ossl_platforms);
+				@current_algorithms = ();
+				@current_algorithms =
+				    grep(!/^$/,
+					 map { $tag{"OPENSSL_NO_".$_} == -1 ? $_ : "" }
+					 @known_algorithms);
+				push @current_algorithms
+				    , grep(!/^$/,
+					 map { $tag{"OPENSSL_USE_".$_} == 1 ? $_ : "" }
+					 @known_algorithms);
+				push @current_algorithms,
+				    grep { /^DEPRECATEDIN_/ && $tag{$_} == 1 }
+				    @known_algorithms;
+				$def .=
+				    "#INFO:"
+					.join(',',@current_platforms).":"
+					    .join(',',@current_algorithms).";";
+				next;
+			}
+			if ($tag{'TRUE'} != -1) {
+				if (/^\s*DEFINE_STACK_OF\s*\(\s*(\w*)\s*\)/
+						|| /^\s*DEFINE_STACK_OF_CONST\s*\(\s*(\w*)\s*\)/) {
+					next;
+				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					$def .= "int d2i_$3(void);";
+					$def .= "int i2d_$3(void);";
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $2_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$2_it","$2_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_fname\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					$def .= "int d2i_$3(void);";
+					$def .= "int i2d_$3(void);";
+					$def .= "int $3_free(void);";
+					$def .= "int $3_new(void);";
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $2_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$2_it","$2_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS\s*\(\s*(\w*)\s*\)/ ||
+					 /^\s*DECLARE_ASN1_FUNCTIONS_const\s*\(\s*(\w*)\s*\)/) {
+					$def .= "int d2i_$1(void);";
+					$def .= "int i2d_$1(void);";
+					$def .= "int $1_free(void);";
+					$def .= "int $1_new(void);";
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $1_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$1_it","$1_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS_const\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					$def .= "int d2i_$2(void);";
+					$def .= "int i2d_$2(void);";
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $2_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$2_it","$2_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_ALLOC_FUNCTIONS\s*\(\s*(\w*)\s*\)/) {
+					$def .= "int $1_free(void);";
+					$def .= "int $1_new(void);";
+					next;
+				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					$def .= "int d2i_$2(void);";
+					$def .= "int i2d_$2(void);";
+					$def .= "int $2_free(void);";
+					$def .= "int $2_new(void);";
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $2_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$2_it","$2_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_ITEM\s*\(\s*(\w*)\s*\)/) {
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int $1_it;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("$1_it","$1_it",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+					next;
+				} elsif (/^\s*DECLARE_ASN1_NDEF_FUNCTION\s*\(\s*(\w*)\s*\)/) {
+					$def .= "int i2d_$1_NDEF(void);";
+				} elsif (/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
+					next;
+				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION\s*\(\s*(\w*)\s*\)/) {
+					$def .= "int $1_print_ctx(void);";
+					next;
+				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					$def .= "int $2_print_ctx(void);";
+					next;
+				} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
+					next;
+				} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_rw_const\s*\(\s*(\w*)\s*,/ ) {
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',"STDIO",@current_algorithms).";";
+					$def .= "int PEM_read_$1(void);";
+					$def .= "int PEM_write_$1(void);";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Things that are everywhere
+					$def .= "int PEM_read_bio_$1(void);";
+					$def .= "int PEM_write_bio_$1(void);";
+					next;
+				} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
+					/^DECLARE_PEM_write_const\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_write_cb\s*\(\s*(\w*)\s*,/ ) {
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',"STDIO",@current_algorithms).";";
+					$def .= "int PEM_write_$1(void);";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Things that are everywhere
+					$def .= "int PEM_write_bio_$1(void);";
+					next;
+				} elsif (/^DECLARE_PEM_read\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_read_cb\s*\(\s*(\w*)\s*,/ ) {
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',"STDIO",@current_algorithms).";";
+					$def .= "int PEM_read_$1(void);";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',"STDIO",@current_algorithms).";";
+					# Things that are everywhere
+					$def .= "int PEM_read_bio_$1(void);";
+					next;
+				} elsif (/^OPENSSL_DECLARE_GLOBAL\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
+					# Variant for platforms that do not
+					# have to access globale variables
+					# in shared libraries through functions
+					$def .=
+					    "#INFO:"
+						.join(',',"!EXPORT_VAR_AS_FUNCTION",@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					$def .= "OPENSSL_EXTERN int _shadow_$2;";
+					$def .=
+					    "#INFO:"
+						.join(',',@current_platforms).":"
+						    .join(',',@current_algorithms).";";
+					# Variant for platforms that have to
+					# access globale variables in shared
+					# libraries through functions
+					&$make_variant("_shadow_$2","_shadow_$2",
+						      "EXPORT_VAR_AS_FUNCTION",
+						      "FUNCTION");
+				} elsif (/^\s*DEPRECATEDIN/) {
+					$parens = count_parens($_);
+					if ($parens == 0) {
+						$def .= do_deprecated($_,
+							\@current_platforms,
+							\@current_algorithms);
+					} else {
+						$stored_multiline = $_;
+						$stored_multiline =~ s|\R$||;
+						print STDERR "DEBUG: Found multiline DEPRECATEDIN starting with: $stored_multiline\n" if $debug;
+						next;
+					}
+				} elsif ($tag{'CONST_STRICT'} != 1) {
+					if (/\{|\/\*|\([^\)]*$/) {
+						$line = $_;
+					} else {
+						$def .= $_;
+					}
+				}
+			}
+		}
+		close(IN);
+		die "$file: Unmatched tags\n" if $#tag >= 0;
+
+		my $algs;
+		my $plays;
+
+		print STDERR "DEBUG: postprocessing ----------\n" if $debug;
+		foreach (split /;/, $def) {
+			my $s; my $k = "FUNCTION"; my $p; my $a;
+			s/^[\n\s]*//g;
+			s/[\n\s]*$//g;
+			next if(/\#undef/);
+			next if(/typedef\W/);
+			next if(/\#define/);
+
+			# Reduce argument lists to empty ()
+			# fold round brackets recursively: (t(*v)(t),t) -> (t{}{},t) -> {}
+			while(/\(.*\)/s) {
+				s/\([^\(\)]+\)/\{\}/gs;
+				s/\(\s*\*\s*(\w+)\s*\{\}\s*\)/$1/gs;	#(*f{}) -> f
+			}
+			# pretend as we didn't use curly braces: {} -> ()
+			s/\{\}/\(\)/gs;
+
+			s/STACK_OF\(\)/void/gs;
+			s/LHASH_OF\(\)/void/gs;
+
+			print STDERR "DEBUG: \$_ = \"$_\"\n" if $debug;
+			if (/^\#INFO:([^:]*):(.*)$/) {
+				$plats = $1;
+				$algs = $2;
+				print STDERR "DEBUG: found info on platforms ($plats) and algorithms ($algs)\n" if $debug;
+				next;
+			} elsif (/^\s*OPENSSL_EXTERN\s.*?(\w+(\{[0-9]+\})?)(\[[0-9]*\])*\s*$/) {
+				$s = $1;
+				$k = "VARIABLE";
+				print STDERR "DEBUG: found external variable $s\n" if $debug;
+			} elsif (/TYPEDEF_\w+_OF/s) {
+				next;
+			} elsif (/(\w+)\s*\(\).*/s) {	# first token prior [first] () is
+				$s = $1;		# a function name!
+				print STDERR "DEBUG: found function $s\n" if $debug;
+			} elsif (/\(/ and not (/=/)) {
+				print STDERR "File $file: cannot parse: $_;\n";
+				next;
+			} else {
+				next;
+			}
+
+			$syms{$s} = 1;
+			$kind{$s} = $k;
+
+			$p = $plats;
+			$a = $algs;
+
+			$platform{$s} =
+			    &reduce_platforms((defined($platform{$s})?$platform{$s}.',':"").$p);
+			$algorithm{$s} .= ','.$a;
+
+			if (defined($variant{$s})) {
+				foreach $v (split /;/,$variant{$s}) {
+					(my $r, my $p, my $k) = split(/:/,$v);
+					my $ip = join ',',map({ /^!(.*)$/ ? $1 : "!".$_ } split /,/, $p);
+					$syms{$r} = 1;
+					if (!defined($k)) { $k = $kind{$s}; }
+					$kind{$r} = $k."(".$s.")";
+					$algorithm{$r} = $algorithm{$s};
+					$platform{$r} = &reduce_platforms($platform{$s}.",".$p.",".$p);
+					$platform{$s} = &reduce_platforms($platform{$s}.','.$ip.','.$ip);
+					print STDERR "DEBUG: \$variant{\"$s\"} = ",$v,"; \$r = $r; \$p = ",$platform{$r},"; \$a = ",$algorithm{$r},"; \$kind = ",$kind{$r},"\n" if $debug;
+				}
+			}
+			print STDERR "DEBUG: \$s = $s; \$p = ",$platform{$s},"; \$a = ",$algorithm{$s},"; \$kind = ",$kind{$s},"\n" if $debug;
+		}
+	}
+
+	# Prune the returned symbols
+
+        delete $syms{"bn_dump1"};
+	$platform{"BIO_s_log"} .= ",!WIN32,!macintosh";
+
+	$platform{"PEM_read_NS_CERT_SEQ"} = "VMS";
+	$platform{"PEM_write_NS_CERT_SEQ"} = "VMS";
+	$platform{"PEM_read_P8_PRIV_KEY_INFO"} = "VMS";
+	$platform{"PEM_write_P8_PRIV_KEY_INFO"} = "VMS";
+
+	# Info we know about
+
+	push @ret, map { $_."\\".&info_string($_,"EXIST",
+					      $platform{$_},
+					      $kind{$_},
+					      $algorithm{$_}) } keys %syms;
+
+	if (keys %unknown_algorithms) {
+		print STDERR "WARNING: mkdef.pl doesn't know the following algorithms:\n";
+		print STDERR "\t",join("\n\t",keys %unknown_algorithms),"\n";
+	}
+	return(@ret);
+}
+
+# Param: string of comma-separated platform-specs.
+sub reduce_platforms
+{
+	my ($platforms) = @_;
+	my $pl = defined($platforms) ? $platforms : "";
+	my %p = map { $_ => 0 } split /,/, $pl;
+	my $ret;
+
+	print STDERR "DEBUG: Entered reduce_platforms with \"$platforms\"\n"
+	    if $debug;
+	# We do this, because if there's code like the following, it really
+	# means the function exists in all cases and should therefore be
+	# everywhere.  By increasing and decreasing, we may attain 0:
+	#
+	# ifndef WIN16
+	#    int foo();
+	# else
+	#    int _fat foo();
+	# endif
+	foreach $platform (split /,/, $pl) {
+		if ($platform =~ /^!(.*)$/) {
+			$p{$1}--;
+		} else {
+			$p{$platform}++;
+		}
+	}
+	foreach $platform (keys %p) {
+		if ($p{$platform} == 0) { delete $p{$platform}; }
+	}
+
+	delete $p{""};
+
+	$ret = join(',',sort(map { $p{$_} < 0 ? "!".$_ : $_ } keys %p));
+	print STDERR "DEBUG: Exiting reduce_platforms with \"$ret\"\n"
+	    if $debug;
+	return $ret;
+}
+
+sub info_string
+{
+	(my $symbol, my $exist, my $platforms, my $kind, my $algorithms) = @_;
+
+	my %a = defined($algorithms) ?
+	    map { $_ => 1 } split /,/, $algorithms : ();
+	my $k = defined($kind) ? $kind : "FUNCTION";
+	my $ret;
+	my $p = &reduce_platforms($platforms);
+
+	delete $a{""};
+
+	$ret = $exist;
+	$ret .= ":".$p;
+	$ret .= ":".$k;
+	$ret .= ":".join(',',sort keys %a);
+	return $ret;
+}
+
+sub maybe_add_info
+{
+	(my $name, *nums, my @symbols) = @_;
+	my $sym;
+	my $new_info = 0;
+	my %syms=();
+
+	foreach $sym (@symbols) {
+		(my $s, my $i) = split /\\/, $sym;
+		if (defined($nums{$s})) {
+			$i =~ s/^(.*?:.*?:\w+)(\(\w+\))?/$1/;
+			(my $n, my $vers, my $dummy) = split /\\/, $nums{$s};
+			if (!defined($dummy) || $i ne $dummy) {
+				$nums{$s} = $n."\\".$vers."\\".$i;
+				$new_info++;
+				print STDERR "DEBUG: maybe_add_info for $s: \"$dummy\" => \"$i\"\n" if $debug;
+			}
+		}
+		$syms{$s} = 1;
+	}
+
+	my @s=sort { &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n") } keys %nums;
+	foreach $sym (@s) {
+		(my $n, my $vers, my $i) = split /\\/, $nums{$sym};
+		if (!defined($syms{$sym}) && $i !~ /^NOEXIST:/) {
+			$new_info++;
+			print STDERR "DEBUG: maybe_add_info for $sym: -> undefined\n" if $debug;
+		}
+	}
+	if ($new_info) {
+		print STDERR "$name: $new_info old symbols have updated info\n";
+		if (!$do_rewrite) {
+			print STDERR "You should do a rewrite to fix this.\n";
+		}
+	} else {
+	}
+}
+
+# Param: string of comma-separated keywords, each possibly prefixed with a "!"
+sub is_valid
+{
+	my ($keywords_txt,$platforms) = @_;
+	my (@keywords) = split /,/,$keywords_txt;
+	my ($falsesum, $truesum) = (0, 1);
+
+	# Param: one keyword
+	sub recognise
+	{
+		my ($keyword,$platforms) = @_;
+
+		if ($platforms) {
+			# platforms
+			if ($keyword eq "VMS" && $VMS) { return 1; }
+			if ($keyword eq "WIN32" && $W32) { return 1; }
+			if ($keyword eq "_WIN32" && $W32) { return 1; }
+			if ($keyword eq "WINNT" && $NT) { return 1; }
+			# Special platforms:
+			# EXPORT_VAR_AS_FUNCTION means that global variables
+			# will be represented as functions.
+			if ($keyword eq "EXPORT_VAR_AS_FUNCTION" && $W32) {
+				return 1;
+			}
+			if ($keyword eq "ZLIB" && $zlib) { return 1; }
+			return 0;
+		} else {
+			# algorithms
+			if ($disabled_algorithms{$keyword} == 1) { return 0;}
+
+			# Nothing recognise as true
+			return 1;
+		}
+	}
+
+	foreach $k (@keywords) {
+		if ($k =~ /^!(.*)$/) {
+			$falsesum += &recognise($1,$platforms);
+		} else {
+			$truesum *= &recognise($k,$platforms);
+		}
+	}
+	print STDERR "DEBUG: [",$#keywords,",",$#keywords < 0,"] is_valid($keywords_txt) => (\!$falsesum) && $truesum = ",(!$falsesum) && $truesum,"\n" if $debug;
+	return (!$falsesum) && $truesum;
+}
+
+sub print_test_file
+{
+	(*OUT,my $name,*nums,my $testall,my @symbols)=@_;
+	my $n = 1; my @e; my @r;
+	my $sym; my $prev = ""; my $prefSSLeay;
+
+	(@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@symbols);
+	(@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:.*/ && !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@symbols);
+	@symbols=((sort @e),(sort @r));
+
+	foreach $sym (@symbols) {
+		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
+		my $v = 0;
+		$v = 1 if $i=~ /^.*?:.*?:VARIABLE/;
+		my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
+		my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
+		if (!defined($nums{$s})) {
+			print STDERR "Warning: $s does not have a number assigned\n"
+			    if(!$do_update);
+		} elsif (is_valid($p,1) && is_valid($a,0)) {
+			my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
+			if ($prev eq $s2) {
+				print OUT "\t/* The following has already appeared previously */\n";
+				print STDERR "Warning: Symbol '",$s2,"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
+			}
+			$prev = $s2;	# To warn about duplicates...
+
+			(my $nn, my $vers, my $ni) = split /\\/, $nums{$s2};
+			if ($v) {
+				print OUT "\textern int $s2; /* type unknown */ /* $nn $ni */\n";
+			} else {
+				print OUT "\textern int $s2(); /* type unknown */ /* $nn $ni */\n";
+			}
+		}
+	}
+}
+
+sub get_version
+{
+   return $config{version};
+}
+
+sub print_def_file
+{
+	(*OUT,my $name,*nums,my @symbols)=@_;
+	my $n = 1; my @e; my @r; my @v; my $prev="";
+	my $liboptions="";
+	my $libname = $name;
+	my $http_vendor = 'www.openssl.org/';
+	my $version = get_version();
+	my $what = "OpenSSL: implementation of Secure Socket Layer";
+	my $description = "$what $version, $name - http://$http_vendor";
+	my $prevsymversion = "", $prevprevsymversion = "";
+        # For VMS
+        my $prevnum = 0;
+        my $symvtextcount = 0;
+
+	if ($W32)
+		{ $libname.="32"; }
+
+        if ($W32)
+                {
+                print OUT <<"EOF";
+;
+; Definition file for the DLL version of the $name library from OpenSSL
+;
+
+LIBRARY         $libname	$liboptions
+
+EOF
+
+		print "EXPORTS\n";
+                }
+        elsif ($VMS)
+                {
+                print OUT <<"EOF";
+CASE_SENSITIVE=YES
+SYMBOL_VECTOR=(-
+EOF
+                $symvtextcount = 16; # length of "SYMBOL_VECTOR=(-"
+                }
+
+	(@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:FUNCTION/,@symbols);
+	(@v)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:VARIABLE/,@symbols);
+        if ($VMS) {
+            # VMS needs to have the symbols on slot number order
+            @symbols=(map { $_->[1] }
+                      sort { $a->[0] <=> $b->[0] }
+                      map { (my $s, my $i) = $_ =~ /^(.*?)\\(.*)$/;
+                            die "Error: $s doesn't have a number assigned\n"
+                                if !defined($nums{$s});
+                            (my $n, my @rest) = split /\\/, $nums{$s};
+                            [ $n, $_ ] } (@e, @r, @v));
+        } else {
+            @symbols=((sort @e),(sort @r), (sort @v));
+        }
+
+	my ($baseversion, $currversion) = get_openssl_version();
+	my $thisversion;
+	do {
+		if (!defined($thisversion)) {
+			$thisversion = $baseversion;
+		} else {
+			$thisversion = get_next_version($thisversion);
+		}
+		foreach $sym (@symbols) {
+			(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
+			my $v = 0;
+			$v = 1 if $i =~ /^.*?:.*?:VARIABLE/;
+			if (!defined($nums{$s})) {
+				die "Error: $s does not have a number assigned\n"
+					if(!$do_update);
+			} else {
+				(my $n, my $symversion, my $dummy) = split /\\/, $nums{$s};
+				next if $symversion ne $thisversion;
+				my %pf = ();
+				my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
+				my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
+				if (is_valid($p,1) && is_valid($a,0)) {
+					my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
+					if ($prev eq $s2) {
+						print STDERR "Warning: Symbol '",$s2,
+							"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),
+							", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
+					}
+					$prev = $s2;	# To warn about duplicates...
+					if($linux) {
+						if ($symversion ne $prevsymversion) {
+							if ($prevsymversion ne "") {
+								if ($prevprevsymversion ne "") {
+									print OUT "} OPENSSL_"
+												."$prevprevsymversion;\n\n";
+								} else {
+									print OUT "};\n\n";
+								}
+							}
+							print OUT "OPENSSL_$symversion {\n    global:\n";
+							$prevprevsymversion = $prevsymversion;
+							$prevsymversion = $symversion;
+						}
+						print OUT "        $s2;\n";
+                                        } elsif ($VMS) {
+                                            while(++$prevnum < $n) {
+                                                my $symline=" ,SPARE -\n  ,SPARE -\n";
+                                                if ($symvtextcount + length($symline) - 2 > 1024) {
+                                                    print OUT ")\nSYMBOL_VECTOR=(-\n";
+                                                    $symvtextcount = 16; # length of "SYMBOL_VECTOR=(-"
+                                                }
+                                                if ($symvtextcount == 16) {
+                                                    # Take away first comma
+                                                    $symline =~ s/,//;
+                                                }
+                                                print OUT $symline;
+                                                $symvtextcount += length($symline) - 2;
+                                            }
+                                            (my $s_uc = $s) =~ tr/a-z/A-Z/;
+                                            my $symtype=
+                                                $v ? "DATA" : "PROCEDURE";
+                                            my $symline=
+                                                ($s_uc ne $s
+                                                 ? " ,$s_uc/$s=$symtype -\n  ,$s=$symtype -\n"
+                                                 : " ,$s=$symtype -\n  ,SPARE -\n");
+                                            if ($symvtextcount + length($symline) - 2 > 1024) {
+                                                print OUT ")\nSYMBOL_VECTOR=(-\n";
+                                                $symvtextcount = 16; # length of "SYMBOL_VECTOR=(-"
+                                            }
+                                            if ($symvtextcount == 16) {
+                                                # Take away first comma
+                                                $symline =~ s/,//;
+                                            }
+                                            print OUT $symline;
+                                            $symvtextcount += length($symline) - 2;
+					} elsif($v) {
+						printf OUT "    %s%-39s DATA\n",
+								($W32)?"":"_",$s2;
+					} else {
+						printf OUT "    %s%s\n",
+								($W32)?"":"_",$s2;
+					}
+				}
+			}
+		}
+	} while ($thisversion ne $currversion);
+	if ($linux) {
+		if ($prevprevsymversion ne "") {
+			print OUT "    local: *;\n} OPENSSL_$prevprevsymversion;\n\n";
+		} else {
+			print OUT "    local: *;\n};\n\n";
+		}
+	} elsif ($VMS) {
+            print OUT ")\n";
+            (my $libvmaj, my $libvmin, my $libvedit) =
+                $currversion =~ /^(\d+)_(\d+)_(\d+)$/;
+            # The reason to multiply the edit number with 100 is to make space
+            # for the possibility that we want to encode the patch letters
+            print OUT "GSMATCH=LEQUAL,",($libvmaj * 100 + $libvmin),",",($libvedit * 100),"\n";
+        }
+	printf OUT "\n";
+}
+
+sub load_numbers
+{
+	my($name)=@_;
+	my(@a,%ret);
+	my $prevversion;
+
+	$max_num = 0;
+	$num_noinfo = 0;
+	$prev = "";
+	$prev_cnt = 0;
+
+	my ($baseversion, $currversion) = get_openssl_version();
+
+	open(IN,"<$name") || die "unable to open $name:$!\n";
+	while (<IN>) {
+		s|\R$||;        # Better chomp
+		s/#.*$//;
+		next if /^\s*$/;
+		@a=split;
+		if (defined $ret{$a[0]}) {
+			# This is actually perfectly OK
+			#print STDERR "Warning: Symbol '",$a[0],"' redefined. old=",$ret{$a[0]},", new=",$a[1],"\n";
+		}
+		if ($max_num > $a[1]) {
+			print STDERR "Warning: Number decreased from ",$max_num," to ",$a[1],"\n";
+		}
+		elsif ($max_num == $a[1]) {
+			# This is actually perfectly OK
+			#print STDERR "Warning: Symbol ",$a[0]," has same number as previous ",$prev,": ",$a[1],"\n";
+			if ($a[0] eq $prev) {
+				$prev_cnt++;
+				$a[0] .= "{$prev_cnt}";
+			}
+		}
+		else {
+			$prev_cnt = 0;
+		}
+		if ($#a < 2) {
+			# Existence will be proven later, in do_defs
+			$ret{$a[0]}=$a[1];
+			$num_noinfo++;
+		} else {
+			#Sanity check the version number
+			if (defined $prevversion) {
+				check_version_lte($prevversion, $a[2]);
+			}
+			check_version_lte($a[2], $currversion);
+			$prevversion = $a[2];
+			$ret{$a[0]}=$a[1]."\\".$a[2]."\\".$a[3]; # \\ is a special marker
+		}
+		$max_num = $a[1] if $a[1] > $max_num;
+		$prev=$a[0];
+	}
+	if ($num_noinfo) {
+		print STDERR "Warning: $num_noinfo symbols were without info.";
+		if ($do_rewrite) {
+			printf STDERR "  The rewrite will fix this.\n";
+		} else {
+			printf STDERR "  You should do a rewrite to fix this.\n";
+		}
+	}
+	close(IN);
+	return(%ret);
+}
+
+sub parse_number
+{
+	(my $str, my $what) = @_;
+	(my $n, my $v, my $i) = split(/\\/,$str);
+	if ($what eq "n") {
+		return $n;
+	} else {
+		return $i;
+	}
+}
+
+sub rewrite_numbers
+{
+	(*OUT,$name,*nums,@symbols)=@_;
+	my $thing;
+
+	my @r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@symbols);
+	my $r; my %r; my %rsyms;
+	foreach $r (@r) {
+		(my $s, my $i) = split /\\/, $r;
+		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
+		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
+		$r{$a} = $s."\\".$i;
+		$rsyms{$s} = 1;
+	}
+
+	my %syms = ();
+	foreach $_ (@symbols) {
+		(my $n, my $i) = split /\\/;
+		$syms{$n} = 1;
+	}
+
+	my @s=sort {
+	    &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n")
+	    || $a cmp $b
+	} keys %nums;
+	foreach $sym (@s) {
+		(my $n, my $vers, my $i) = split /\\/, $nums{$sym};
+		next if defined($i) && $i =~ /^.*?:.*?:\w+\(\w+\)/;
+		next if defined($rsyms{$sym});
+		print STDERR "DEBUG: rewrite_numbers for sym = ",$sym,": i = ",$i,", n = ",$n,", rsym{sym} = ",$rsyms{$sym},"syms{sym} = ",$syms{$sym},"\n" if $debug;
+		$i="NOEXIST::FUNCTION:"
+			if !defined($i) || $i eq "" || !defined($syms{$sym});
+		my $s2 = $sym;
+		$s2 =~ s/\{[0-9]+\}$//;
+		printf OUT "%s%-39s %d\t%s\t%s\n","",$s2,$n,$vers,$i;
+		if (exists $r{$sym}) {
+			(my $s, $i) = split /\\/,$r{$sym};
+			my $s2 = $s;
+			$s2 =~ s/\{[0-9]+\}$//;
+			printf OUT "%s%-39s %d\t%s\t%s\n","",$s2,$n,$vers,$i;
+		}
+	}
+}
+
+sub update_numbers
+{
+	(*OUT,$name,*nums,my $start_num, my @symbols)=@_;
+	my $new_syms = 0;
+	my $basevers;
+	my $vers;
+
+	($basevers, $vers) = get_openssl_version();
+
+	my @r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@symbols);
+	my $r; my %r; my %rsyms;
+	foreach $r (@r) {
+		(my $s, my $i) = split /\\/, $r;
+		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
+		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
+		$r{$a} = $s."\\".$i;
+		$rsyms{$s} = 1;
+	}
+
+	foreach $sym (@symbols) {
+		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
+		next if $i =~ /^.*?:.*?:\w+\(\w+\)/;
+		next if defined($rsyms{$sym});
+		die "ERROR: Symbol $sym had no info attached to it."
+		    if $i eq "";
+		if (!exists $nums{$s}) {
+			$new_syms++;
+			my $s2 = $s;
+			$s2 =~ s/\{[0-9]+\}$//;
+			printf OUT "%s%-39s %d\t%s\t%s\n","",$s2, ++$start_num,$vers,$i;
+			if (exists $r{$s}) {
+				($s, $i) = split /\\/,$r{$s};
+				$s =~ s/\{[0-9]+\}$//;
+				printf OUT "%s%-39s %d\t%s\t%s\n","",$s, $start_num,$vers,$i;
+			}
+		}
+	}
+	if($new_syms) {
+		print STDERR "$name: Added $new_syms new symbols\n";
+	} else {
+		print STDERR "$name: No new symbols added\n";
+	}
+}
+
+sub check_existing
+{
+	(*nums, my @symbols)=@_;
+	my %existing; my @remaining;
+	@remaining=();
+	foreach $sym (@symbols) {
+		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
+		$existing{$s}=1;
+	}
+	foreach $sym (keys %nums) {
+		if (!exists $existing{$sym}) {
+			push @remaining, $sym;
+		}
+	}
+	if(@remaining) {
+		print STDERR "The following symbols do not seem to exist:\n";
+		foreach $sym (@remaining) {
+			print STDERR "\t",$sym,"\n";
+		}
+	}
+}
+
+sub count_parens
+{
+	my $line = shift(@_);
+
+	my $open = $line =~ tr/\(//;
+	my $close = $line =~ tr/\)//;
+
+	return $open - $close;
+}
+
+#Parse opensslv.h to get the current version number. Also work out the base
+#version, i.e. the lowest version number that is binary compatible with this
+#version
+sub get_openssl_version()
+{
+	my $fn = catfile($config{sourcedir},"include","openssl","opensslv.h");
+	open (IN, "$fn") || die "Can't open opensslv.h";
+
+	while(<IN>) {
+		if (/OPENSSL_VERSION_TEXT\s+"OpenSSL (\d\.\d\.)(\d[a-z]*)(-| )/) {
+			my $suffix = $2;
+			(my $baseversion = $1) =~ s/\./_/g;
+			close IN;
+			return ($baseversion."0", $baseversion.$suffix);
+		}
+	}
+	die "Can't find OpenSSL version number\n";
+}
+
+#Given an OpenSSL version number, calculate the next version number. If the
+#version number gets to a.b.czz then we go to a.b.(c+1)
+sub get_next_version()
+{
+	my $thisversion = shift;
+
+	my ($base, $letter) = $thisversion =~ /^(\d_\d_\d)([a-z]{0,2})$/;
+
+	if ($letter eq "zz") {
+		my $lastnum = substr($base, -1);
+		return substr($base, 0, length($base)-1).(++$lastnum);
+	}
+	return $base.get_next_letter($letter);
+}
+
+#Given the letters off the end of an OpenSSL version string, calculate what
+#the letters for the next release would be.
+sub get_next_letter()
+{
+	my $thisletter = shift;
+	my $baseletter = "";
+	my $endletter;
+
+	if ($thisletter eq "") {
+		return "a";
+	}
+	if ((length $thisletter) > 1) {
+		($baseletter, $endletter) = $thisletter =~ /([a-z]+)([a-z])/;
+	} else {
+		$endletter = $thisletter;
+	}
+
+	if ($endletter eq "z") {
+		return $thisletter."a";
+	} else {
+		return $baseletter.(++$endletter);
+	}
+}
+
+#Check if a version is less than or equal to the current version. Its a fatal
+#error if not. They must also only differ in letters, or the last number (i.e.
+#the first two numbers must be the same)
+sub check_version_lte()
+{
+	my ($testversion, $currversion) = @_;
+	my $lentv;
+	my $lencv;
+	my $cvbase;
+
+	my ($cvnums) = $currversion =~ /^(\d_\d_\d)[a-z]*$/;
+	my ($tvnums) = $testversion =~ /^(\d_\d_\d)[a-z]*$/;
+
+	#Die if we can't parse the version numbers or they don't look sane
+	die "Invalid version number: $testversion and $currversion\n"
+		if (!defined($cvnums) || !defined($tvnums)
+			|| length($cvnums) != 5
+			|| length($tvnums) != 5);
+
+	#If the base versions (without letters) don't match check they only differ
+	#in the last number
+	if ($cvnums ne $tvnums) {
+		die "Invalid version number: $testversion "
+			."for current version $currversion\n"
+			if (substr($cvnums, 0, 4) ne substr($tvnums, 0, 4));
+		return;
+	}
+	#If we get here then the base version (i.e. the numbers) are the same - they
+	#only differ in the letters
+
+	$lentv = length $testversion;
+	$lencv = length $currversion;
+
+	#If the testversion has more letters than the current version then it must
+	#be later (or malformed)
+	if ($lentv > $lencv) {
+		die "Invalid version number: $testversion "
+			."is greater than $currversion\n";
+	}
+
+	#Get the last letter from the current version
+	my ($cvletter) = $currversion =~ /([a-z])$/;
+	if (defined $cvletter) {
+		($cvbase) = $currversion =~ /(\d_\d_\d[a-z]*)$cvletter$/;
+	} else {
+		$cvbase = $currversion;
+	}
+	die "Unable to parse version number $currversion" if (!defined $cvbase);
+	my $tvbase;
+	my ($tvletter) = $testversion =~ /([a-z])$/;
+	if (defined $tvletter) {
+		($tvbase) = $testversion =~ /(\d_\d_\d[a-z]*)$tvletter$/;
+	} else {
+		$tvbase = $testversion;
+	}
+	die "Unable to parse version number $testversion" if (!defined $tvbase);
+
+	if ($lencv > $lentv) {
+		#If current version has more letters than testversion then testversion
+		#minus the final letter must be a substring of the current version
+		die "Invalid version number $testversion "
+			."is greater than $currversion or is invalid\n"
+			if (index($cvbase, $tvbase) != 0);
+	} else {
+		#If both versions have the same number of letters then they must be
+		#equal up to the last letter, and the last letter in testversion must
+		#be less than or equal to the last letter in current version.
+		die "Invalid version number $testversion "
+			."is greater than $currversion\n"
+			if (($cvbase ne $tvbase) && ($tvletter gt $cvletter));
+	}
+}
+
+sub do_deprecated()
+{
+	my ($decl, $plats, $algs) = @_;
+	$decl =~ /^\s*(DEPRECATEDIN_\d+_\d+_\d+)\s*\((.*)\)\s*$/
+            or die "Bad DEPRECTEDIN: $decl\n";
+	my $info1 .= "#INFO:";
+	$info1 .= join(',', @{$plats}) . ":";
+	my $info2 = $info1;
+	$info1 .= join(',',@{$algs}, $1) . ";";
+	$info2 .= join(',',@{$algs}) . ";";
+	return $info1 . $2 . ";" . $info2;
+}
