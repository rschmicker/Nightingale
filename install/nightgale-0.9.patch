diff -rupN openssl-master/compile_night_test.sh openssl/compile_night_test.sh
--- openssl-master/compile_night_test.sh	1969-12-31 19:00:00.000000000 -0500
+++ openssl/compile_night_test.sh	2017-03-20 19:42:41.933099766 -0400
@@ -0,0 +1,8 @@
+rm -f night_test
+rm -f night_evp_test
+./config && make update && make -j 12 && \
+gcc -I./include -L. -Wextra -Wall -o night_evp_test night_evp_test.c -lcrypto && \
+gcc -I./include -L. -Wextra -Wall -o night_test night_test.c -lcrypto && \
+LD_LIBRARY_PATH=. ./night_test && \
+LD_LIBRARY_PATH=. ./night_evp_test && \
+LD_LIBRARY_PATH=. ./apps/openssl speed -elapsed -evp nightgale
diff -rupN openssl-master/Configure openssl/Configure
--- openssl-master/Configure	2017-03-20 17:09:57.000000000 -0400
+++ openssl/Configure	2017-03-20 19:42:41.937101767 -0400
@@ -310,7 +310,7 @@ $config{dirs} = [ "crypto", "ssl", "engi
 # crypto/ subdirectories to build
 $config{sdirs} = [
     "objects",
-    "md2", "md4", "md5", "sha", "mdc2", "hmac", "ripemd", "whrlpool", "poly1305", "blake2", "siphash",
+    "md2", "md4", "nightgale", "md5", "sha", "mdc2", "hmac", "ripemd", "whrlpool", "poly1305", "blake2", "siphash",
     "des", "aes", "rc2", "rc4", "rc5", "idea", "aria", "bf", "cast", "camellia", "seed", "chacha", "modes",
     "bn", "ec", "rsa", "dsa", "dh", "dso", "engine",
     "buffer", "bio", "stack", "lhash", "rand", "err",
diff -rupN openssl-master/crypto/evp/build.info openssl/crypto/evp/build.info
--- openssl-master/crypto/evp/build.info	2017-03-20 17:09:57.000000000 -0400
+++ openssl/crypto/evp/build.info	2017-03-20 19:42:41.937101767 -0400
@@ -3,7 +3,7 @@ SOURCE[../../libcrypto]=\
         encode.c digest.c evp_enc.c evp_key.c evp_cnf.c \
         e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
         e_rc4.c e_aes.c names.c e_seed.c e_aria.c \
-        e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
+        e_night.c e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
         m_null.c m_md2.c m_md4.c m_md5.c m_sha1.c m_wp.c \
         m_md5_sha1.c m_mdc2.c m_ripemd.c \
         p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
diff -rupN openssl-master/crypto/evp/c_allc.c openssl/crypto/evp/c_allc.c
--- openssl-master/crypto/evp/c_allc.c	2017-03-20 17:09:57.000000000 -0400
+++ openssl/crypto/evp/c_allc.c	2017-03-20 19:42:41.937101767 -0400
@@ -16,7 +16,8 @@
 
 void openssl_add_all_ciphers_int(void)
 {
-
+    EVP_add_cipher(EVP_nightgale());
+    EVP_add_cipher_alias(SN_nightgale, "nightgale");
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cfb());
     EVP_add_cipher(EVP_des_cfb1());
diff -rupN openssl-master/crypto/evp/e_night.c openssl/crypto/evp/e_night.c
--- openssl-master/crypto/evp/e_night.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/evp/e_night.c	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,58 @@
+#include <stdio.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/nightgale.h>
+#include "internal/cryptlib.h"
+#include "internal/evp_int.h"
+
+typedef struct {
+	SUB s;
+	union {
+		void (*cipher) (SUB *s, size_t len, const unsigned char *in,
+                                    unsigned char *out);
+	} stream;
+} EVP_NIGHT_KEY;
+
+#define data(ctx) ((EVP_NIGHT_KEY *)EVP_CIPHER_CTX_get_cipher_data(ctx))
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+				const unsigned char *iv, int enc);
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl);
+
+static const EVP_CIPHER nightgale_cipher = {
+	NID_nightgale,
+	1, 1, 0, // block_size, key size, iv size 
+	0,
+	nightgale_init_key, // function pointer to key init
+	nightgale_c, // function pointer to cipher operation
+	NULL, // clean up function pointer
+	sizeof(EVP_NIGHT_KEY), // size of ctx
+	NULL,
+	NULL,
+	NULL,
+	NULL	
+};
+
+const EVP_CIPHER *EVP_nightgale(void)
+{
+	return (&nightgale_cipher);
+}
+
+static int nightgale_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                                const unsigned char *iv, int enc)
+{
+	enc ? nightgale_enc_set_key(&data(ctx)->s) : 
+			nightgale_dec_set_key(&data(ctx)->s);
+	data(ctx)->stream.cipher = enc ? encrypt_night : decrypt_night;
+	return 1;
+}
+
+static int nightgale_c(EVP_CIPHER_CTX *ctx, unsigned char *out,
+				const unsigned char *in, size_t inl)
+{
+	(*data(ctx)->stream.cipher) (&data(ctx)->s, inl, in, out);
+	return 1;
+}
+
diff -rupN openssl-master/crypto/nightgale/build.info openssl/crypto/nightgale/build.info
--- openssl-master/crypto/nightgale/build.info	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/build.info	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,3 @@
+LIBS=../../libcrypto
+SOURCE[../../libcrypto]=\
+sub_t.c nightgale_c.c
diff -rupN openssl-master/crypto/nightgale/nightgale_c.c openssl/crypto/nightgale/nightgale_c.c
--- openssl-master/crypto/nightgale/nightgale_c.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/nightgale_c.c	2017-03-20 19:43:06.729491768 -0400
@@ -0,0 +1,98 @@
+#include "nightgale_c.h"
+
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char* in, 
+                    unsigned char * out){
+
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)out;
+    uint64_t *plain_text = (uint64_t *)in;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word;
+
+    // Encrypt buffers
+    root = anchor;
+    for(int i = 0; i < word_count; ++i){
+        decimal_word = root ^ plain_text[i] ^ hamming_mask;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int k = 0; k < WORD_SIZE; ++k) pre_sub[k] = s->sub[(int)pre_sub[k]];
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        enc_message[i] = decimal_word ^ key ^ anchor;
+        root = decimal_word;
+    }
+ }
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                                unsigned char *out){
+    
+    size_t word_count = len / WORD_SIZE;
+    if( len % WORD_SIZE != 0 ) ++word_count;
+    
+    uint64_t *enc_message = (uint64_t *)in;
+    uint64_t *dec_message = (uint64_t *)out;
+
+    // PNRG initialization
+    void *temp;
+    pcg64_random_t rng_unique, rng_anch, rng_ham;
+    pcg128_t s1_unique, anchor_seed, ham_seed;
+    
+    temp = s->seed1;
+    s1_unique = *(pcg128_t *)temp;
+
+    temp = &s->digest[0];
+    anchor_seed = *(pcg128_t *)temp;
+
+    temp = &s->digest[SHA256_DIGEST_LENGTH/2];
+    ham_seed = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng_unique, s1_unique, 5);
+    pcg64_srandom_r(&rng_anch, anchor_seed, 6);
+    pcg64_srandom_r(&rng_ham, ham_seed, 7);
+
+    // Anchor must call the PNRG first
+    uint64_t anchor = pcg64_random_r(&rng_anch), root;
+    uint64_t hamming_mask = pcg64_random_r(&rng_ham);
+
+    unsigned char *pre_sub;
+    uint64_t decimal_word, pre_sub_decimal_word;
+
+    // Decrypt here
+    root = anchor;
+    for(int i = 0; i < word_count; ++i) {
+        uint64_t key = pcg64_random_r(&rng_unique);
+        anchor = rotr64(anchor, key&MASK);
+        decimal_word = enc_message[i] ^ key ^ anchor;
+	pre_sub_decimal_word = decimal_word;
+        pre_sub = (unsigned char *)&decimal_word;
+        for(int j = 0; j < WORD_SIZE; ++j) pre_sub[j] = s->reverse_sub[(int)pre_sub[j]];
+        dec_message[i] = root ^ decimal_word ^ hamming_mask;
+        root = pre_sub_decimal_word;
+    }
+}
+
diff -rupN openssl-master/crypto/nightgale/nightgale_c.h openssl/crypto/nightgale/nightgale_c.h
--- openssl-master/crypto/nightgale/nightgale_c.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/nightgale_c.h	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,32 @@
+#ifndef HEADER_NIGHTGALE_H
+#define HEADER_NIGHTGALE_H
+
+#include "pcg_variants.h"
+#include "sub_t.h"
+
+#define WORD_SIZE 8
+#define MASK 0xfc00000000000000
+
+//-----------------------------------------------------------------------------
+// Encrypt
+//-----------------------------------------------------------------------------
+void encrypt_night(SUB *s, size_t len, const unsigned char *in, 
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Decrypt
+//-----------------------------------------------------------------------------
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+//-----------------------------------------------------------------------------
+// Anchor rotation based off the last 6 bits of the key
+//-----------------------------------------------------------------------------
+inline uint64_t rotr64 (uint64_t n, unsigned int c){
+    const unsigned int mask = (CHAR_BIT*sizeof(n)-1);
+    c &= mask;
+    return (n>>c) | (n<<( (-c)&mask ));
+}
+
+#endif
+
diff -rupN openssl-master/crypto/nightgale/pcg_variants.h openssl/crypto/nightgale/pcg_variants.h
--- openssl-master/crypto/nightgale/pcg_variants.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/pcg_variants.h	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,351 @@
+/*
+ * PCG Random Number Generation for C.
+ *
+ * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * For additional information about the PCG random number generation scheme,
+ * including its license and other licensing options, visit
+ *
+ *     http://www.pcg-random.org
+ */
+
+/*
+ * This code is derived from the canonical C++ PCG implementation, which
+ * has many additional features and is preferable if you can use C++ in
+ * your project.
+ *
+ * Much of the derivation was performed mechanically.  In particular, the
+ * output functions were generated by compiling the C++ output functions
+ * into LLVM bitcode and then transforming that using the LLVM C backend
+ * (from https://github.com/draperlaboratory/llvm-cbe), and then
+ * postprocessing and hand editing the output.
+ *
+ * Much of the remaining code was generated by C-preprocessor metaprogramming.
+
+pcg-advance-16.c pcg-advance-16.c\
+    pcg-advance-8.c pcg-global-32.c pcg-global-32.c\
+    pcg-global-32.c pcg-output-32.c pcg-output-8.c\
+    pcg-output-8.c pcg-rngs-16.c pcg-rngs-16.c\
+    pcg-rngs-8.c
+ 
+ */
+
+#ifndef PCG_VARIANTS_H_INCLUDED
+#define PCG_VARIANTS_H_INCLUDED 1
+
+#include <inttypes.h>
+
+#if __SIZEOF_INT128__
+    typedef __uint128_t pcg128_t;
+    #define PCG_128BIT_CONSTANT(high,low) \
+            ((((pcg128_t)high) << 64) + low)
+    #define PCG_HAS_128BIT_OPS 1
+#endif
+
+#if __GNUC_GNU_INLINE__  &&  !defined(__cplusplus)
+    #error Nonstandard GNU inlining semanatics. Compile with -std=c99 or better.
+    // We could instead use macros PCG_INLINE and PCG_EXTERN_INLINE
+    // but better to just reject ancient C code.
+#endif
+
+/*
+ * Rotate helper functions.
+ */
+
+inline uint8_t pcg_rotr_8(uint8_t value, unsigned int rot)
+{
+/* Unfortunately, clang is kinda pathetic when  it comes to properly
+ * recognizing idiomatic rotate code, so for clang we actually provide
+ * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss.
+ */
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorb   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 7));
+#endif
+}
+
+inline uint16_t pcg_rotr_16(uint16_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorw   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 15));
+#endif
+}
+
+inline uint32_t pcg_rotr_32(uint32_t value, unsigned int rot)
+{
+#if PCG_USE_INLINE_ASM && __clang__ && (__x86_64__  || __i386__)
+    asm ("rorl   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 31));
+#endif
+}
+
+inline uint64_t pcg_rotr_64(uint64_t value, unsigned int rot)
+{
+#if 0 && PCG_USE_INLINE_ASM && __clang__ && __x86_64__
+    // For whatever reason, clang actually *does* generator rotq by
+    // itself, so we don't need this code.
+    asm ("rorq   %%cl, %0" : "=r" (value) : "0" (value), "c" (rot));
+    return value;
+#else
+    return (value >> rot) | (value << ((- rot) & 63));
+#endif
+}
+
+/*
+ * Output functions.  These are the core of the PCG generation scheme.
+ */
+
+
+
+
+
+
+// XSL RR (only defined for >= 64 bits)
+
+inline uint64_t pcg_output_xsl_rr_128_64(pcg128_t state)//////////////////////////////////////////////////////////////////////////////
+{
+    return pcg_rotr_64(((uint64_t)(state >> 64u)) ^ (uint64_t)state,
+                       state >> 122u);
+}
+
+
+#define PCG_DEFAULT_MULTIPLIER_8   141U
+#define PCG_DEFAULT_MULTIPLIER_16  12829U
+#define PCG_DEFAULT_MULTIPLIER_32  747796405U
+#define PCG_DEFAULT_MULTIPLIER_64  6364136223846793005ULL
+
+#define PCG_DEFAULT_INCREMENT_8    77U
+#define PCG_DEFAULT_INCREMENT_16   47989U
+#define PCG_DEFAULT_INCREMENT_32   2891336453U
+#define PCG_DEFAULT_INCREMENT_64   1442695040888963407ULL
+
+#define PCG_DEFAULT_MULTIPLIER_128 \
+        PCG_128BIT_CONSTANT(2549297995355413924ULL,4865540595714422341ULL)
+#define PCG_DEFAULT_INCREMENT_128  \
+        PCG_128BIT_CONSTANT(6364136223846793005ULL,1442695040888963407ULL)
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG_STATE_ONESEQ_8_INITIALIZER      { 0xd7U }
+#define PCG_STATE_ONESEQ_16_INITIALIZER     { 0x20dfU }
+#define PCG_STATE_ONESEQ_32_INITIALIZER     { 0x46b56677U }
+#define PCG_STATE_ONESEQ_64_INITIALIZER     { 0x4d595df4d0f33173ULL }
+#define PCG_STATE_ONESEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0xb8dc10e158a92392ULL, 0x98046df007ec0a53ULL) }
+
+#define PCG_STATE_UNIQUE_8_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG_STATE_UNIQUE_16_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG_STATE_UNIQUE_32_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG_STATE_UNIQUE_64_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG_STATE_UNIQUE_128_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG_STATE_MCG_8_INITIALIZER         { 0xe5U }
+#define PCG_STATE_MCG_16_INITIALIZER        { 0xa5e5U }
+#define PCG_STATE_MCG_32_INITIALIZER        { 0xd15ea5e5U }
+#define PCG_STATE_MCG_64_INITIALIZER        { 0xcafef00dd15ea5e5ULL }
+#define PCG_STATE_MCG_128_INITIALIZER                                          \
+    { PCG_128BIT_CONSTANT(0x0000000000000000ULL, 0xcafef00dd15ea5e5ULL) }
+
+#define PCG_STATE_SETSEQ_8_INITIALIZER      { 0x9bU, 0xdbU }
+#define PCG_STATE_SETSEQ_16_INITIALIZER     { 0xe39bU, 0x5bdbU }
+#define PCG_STATE_SETSEQ_32_INITIALIZER     { 0xec02d89bU, 0x94b95bdbU }
+#define PCG_STATE_SETSEQ_64_INITIALIZER                                        \
+    { 0x853c49e6748fea9bULL, 0xda3e39cb94b95bdbULL }
+#define PCG_STATE_SETSEQ_128_INITIALIZER                                       \
+    { PCG_128BIT_CONSTANT(0x979c9a98d8462005ULL, 0x7d3e9cb6cfe0549bULL),       \
+      PCG_128BIT_CONSTANT(0x0000000000000001ULL, 0xda3e39cb94b95bdbULL) }
+
+/* Representations for the oneseq, mcg, and unique variants */
+
+struct pcg_state_8 {
+    uint8_t state;
+};
+
+struct pcg_state_16 {
+    uint16_t state;
+};
+
+struct pcg_state_32 {
+    uint32_t state;
+};
+
+struct pcg_state_64 {
+    uint64_t state;
+};
+
+struct pcg_state_128 {
+    pcg128_t state;
+};
+
+/* Representations setseq variants */
+
+struct pcg_state_setseq_8 {
+    uint8_t state;
+    uint8_t inc;
+};
+
+struct pcg_state_setseq_16 {
+    uint16_t state;
+    uint16_t inc;
+};
+
+struct pcg_state_setseq_32 {
+    uint32_t state;
+    uint32_t inc;
+};
+
+struct pcg_state_setseq_64 {
+    uint64_t state;
+    uint64_t inc;
+};
+
+struct pcg_state_setseq_128 {
+    pcg128_t state;
+    pcg128_t inc;
+};
+
+
+/* Functions to advance the underlying LCG, one version for each size and
+ * each style.  These functions are considered semi-private.  There is rarely
+ * a good reason to call them directly.
+ */
+
+
+
+/* Functions to seed the RNG state, one version for each size and each
+ * style.  Unlike the step functions, regular users can and should call
+ * these functions.
+ */
+
+
+
+
+
+inline void pcg_setseq_128_step_r(struct pcg_state_setseq_128* rng)/////////////////////////////////////////////////////////////////////////////
+{
+    rng->state = rng->state * PCG_DEFAULT_MULTIPLIER_128 + rng->inc;
+}
+
+inline void pcg_setseq_128_srandom_r(struct pcg_state_setseq_128* rng,////////////////////////////////////////////////////////////////////////////
+                                     pcg128_t initstate, pcg128_t initseq)
+{
+    rng->state = 0U;
+    rng->inc = (initseq << 1u) | 1u;
+    pcg_setseq_128_step_r(rng);
+    rng->state += initstate;
+    pcg_setseq_128_step_r(rng);
+}
+
+/* Now, finally we create each of the individual generators. We provide
+ * a random_r function that provides a random number of the appropriate
+ * type (using the full range of the type) and a boundedrand_r version
+ * that provides
+ *
+ * Implementation notes for boundedrand_r:
+ *
+ *     To avoid bias, we need to make the range of the RNG a multiple of
+ *     bound, which we do by dropping output less than a threshold.
+ *     Let's consider a 32-bit case...  A naive scheme to calculate the
+ *     threshold would be to do
+ *
+ *         uint32_t threshold = 0x100000000ull % bound;
+ *
+ *     but 64-bit div/mod is slower than 32-bit div/mod (especially on
+ *     32-bit platforms).  In essence, we do
+ *
+ *         uint32_t threshold = (0x100000000ull-bound) % bound;
+ *
+ *     because this version will calculate the same modulus, but the LHS
+ *     value is less than 2^32.
+ *
+ *     (Note that using modulo is only wise for good RNGs, poorer RNGs
+ *     such as raw LCGs do better using a technique based on division.)
+ *     Empricical tests show that division is preferable to modulus for
+ *     reducting the range of an RNG.  It's faster, and sometimes it can
+ *     even be statistically prefereable.
+ */
+
+/* Generation functions for XSH RS */
+
+
+inline uint64_t
+pcg_setseq_128_xsl_rr_64_random_r(struct pcg_state_setseq_128* rng)///////////////////////////////////////////////////////////////////////
+{
+    pcg_setseq_128_step_r(rng);
+    return pcg_output_xsl_rr_128_64(rng->state);
+}
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_64      pcg32_random_t;
+typedef struct pcg_state_64             pcg32s_random_t;
+typedef struct pcg_state_64             pcg32u_random_t;
+typedef struct pcg_state_64             pcg32f_random_t;
+
+
+//// Typedefs
+typedef struct pcg_state_setseq_128     pcg64_random_t;
+typedef struct pcg_state_128            pcg64s_random_t;
+typedef struct pcg_state_128            pcg64u_random_t;
+typedef struct pcg_state_128            pcg64f_random_t;
+//// random_r
+#define pcg64_random_r                  pcg_setseq_128_xsl_rr_64_random_r
+
+//// srandom_r
+#define pcg64_srandom_r                 pcg_setseq_128_srandom_r
+
+
+ uint64_t pcg64_random();
+ void     pcg64_srandom(pcg128_t seed, pcg128_t seq);
+
+/*
+ * Static initialization constants (if you can't call srandom for some
+ * bizarre reason).
+ */
+
+#define PCG32_INITIALIZER       PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG32U_INITIALIZER      PCG_STATE_UNIQUE_64_INITIALIZER
+#define PCG32S_INITIALIZER      PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG32F_INITIALIZER      PCG_STATE_MCG_64_INITIALIZER
+
+#define PCG64_INITIALIZER       PCG_STATE_SETSEQ_128_INITIALIZER
+#define PCG64U_INITIALIZER      PCG_STATE_UNIQUE_128_INITIALIZER
+#define PCG64S_INITIALIZER      PCG_STATE_ONESEQ_128_INITIALIZER
+#define PCG64F_INITIALIZER      PCG_STATE_MCG_128_INITIALIZER
+
+#define PCG8SI_INITIALIZER      PCG_STATE_ONESEQ_8_INITIALIZER
+#define PCG16SI_INITIALIZER     PCG_STATE_ONESEQ_16_INITIALIZER
+#define PCG32SI_INITIALIZER     PCG_STATE_ONESEQ_32_INITIALIZER
+#define PCG64SI_INITIALIZER     PCG_STATE_ONESEQ_64_INITIALIZER
+#define PCG128SI_INITIALIZER    PCG_STATE_ONESEQ_128_INITIALIZER
+
+#define PCG8I_INITIALIZER       PCG_STATE_SETSEQ_8_INITIALIZER
+#define PCG16I_INITIALIZER      PCG_STATE_SETSEQ_16_INITIALIZER
+#define PCG32I_INITIALIZER      PCG_STATE_SETSEQ_32_INITIALIZER
+#define PCG64I_INITIALIZER      PCG_STATE_SETSEQ_64_INITIALIZER
+#define PCG128I_INITIALIZER     PCG_STATE_SETSEQ_128_INITIALIZER
+
+#endif // PCG_VARIANTS_H_INCLUDED
+
diff -rupN openssl-master/crypto/nightgale/sub_t.c openssl/crypto/nightgale/sub_t.c
--- openssl-master/crypto/nightgale/sub_t.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/sub_t.c	2017-03-20 19:43:19.695971767 -0400
@@ -0,0 +1,170 @@
+#include "sub_t.h"
+
+//-----------------------------------------------------------------------------
+void nightgale_dec_set_key(SUB *s){
+    generate_hash(s, RSA_KEY);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s){
+    generate_key(s);
+    generate_hash(s, RSA_KEY);
+    generate_seeds(s);
+    generate_rands(s);
+    shuffle(s);
+}
+
+//-----------------------------------------------------------------------------
+size_t get_file_length(FILE *fp) {
+    fseek(fp, 0L, SEEK_CUR);
+    long unsigned int mypos = ftell(fp);
+    fseek(fp, 0L, SEEK_END);
+    long unsigned int filesize = ftell(fp);
+    fseek(fp, mypos, SEEK_SET);
+    return filesize;
+ }
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne){
+    BIO_free_all(bp_private);
+    RSA_free(r);
+    BN_free(bne);
+}
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void *elem1, const void *elem2){
+    indexes *i1, *i2;
+    i1 = (indexes *)elem1;
+    i2 = (indexes *)elem2;
+    return i1->value - i2->value;
+}
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s){
+    indexes knuth_sort[SUB_SIZE];
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        knuth_sort[i].index = i+1;
+        knuth_sort[i].value = s->sub_rands[i];
+    }
+
+    qsort(knuth_sort, SUB_SIZE, sizeof(indexes), cmp);
+
+    for(int i = 0; i < SUB_SIZE; i++){
+        s->sub[i] = (unsigned char)knuth_sort[i].index;
+        s->reverse_sub[(unsigned char)knuth_sort[i].index] = i;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s){
+    pcg64_random_t rng1, rng2, rng3, rng4;
+    pcg128_t round = 5;
+    pcg128_t s1, s2, s3, s4;
+
+    void *temp;
+
+    temp = s->seed1;
+    s1 = *(pcg128_t *)temp;
+    
+    temp = s->seed2;
+    s2 = *(pcg128_t *)temp;
+
+    temp = s->seed3;
+    s3 = *(pcg128_t *)temp;
+
+    temp = s->seed4;
+    s4 = *(pcg128_t *)temp;
+
+    pcg64_srandom_r(&rng1, s1, round);
+    pcg64_srandom_r(&rng2, s2, round);
+    pcg64_srandom_r(&rng3, s3, round);
+    pcg64_srandom_r(&rng4, s4, round);
+
+    for(int i = 0; i < 64; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng1);
+    }
+    for(int i = 64; i < 128; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng2);
+    }
+    for(int i = 128; i < 192; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng3);
+    }
+    for(int i = 192; i < 256; ++i){
+        s->sub_rands[i] = pcg64_random_r(&rng4);
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s){
+    memcpy(s->seed1, s->hash, SEED_SIZE);
+    memcpy(s->seed2, s->hash + SEED_SIZE, SEED_SIZE);
+    memcpy(s->seed3, s->hash + SEED_SIZE*2, SEED_SIZE);
+    memcpy(s->seed4, s->hash + SEED_SIZE*3, SEED_SIZE);
+}
+
+//-----------------------------------------------------------------------------
+// Generate Hash from private key file from RSA
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const char* key_file){
+    FILE *fp = fopen(key_file, "rb");
+    if( !fp ) perror("Error reading private key from RSA."),exit(EXIT_FAILURE);
+
+    size_t filesize = get_file_length(fp);
+    unsigned char *buffer = malloc(filesize);
+    size_t nread = fread(buffer, sizeof(unsigned char), filesize, fp);
+
+    if( ferror(fp) || nread != filesize) perror("Error reading private key from RSA."),
+                        exit(EXIT_FAILURE);
+
+    SHA512(buffer, filesize, s->hash);
+    SHA256(s->hash, SHA512_DIGEST_LENGTH, s->digest);
+
+    free(buffer);
+    fclose(fp);
+}
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key(){
+    int             ret = 0;
+    int             bits = 2048;
+    unsigned long   e = RSA_F4;
+    RSA             *r = NULL;
+    BIGNUM          *bne = NULL;
+    BIO             *bp_private = NULL;
+
+    bne = BN_new();
+    ret = BN_set_word(bne,e);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    r = RSA_new();
+    ret = RSA_generate_key_ex(r, bits, bne, NULL);
+    if(ret != 1){
+        free_r(bp_private, r, bne);
+        printf("Failue\n");
+    }
+
+    bp_private = BIO_new_file(RSA_KEY, "w+");
+    ret = PEM_write_bio_RSAPrivateKey(bp_private, r, NULL, NULL, 0, NULL, NULL);
+
+    free_r(bp_private, r, bne);
+}
+
diff -rupN openssl-master/crypto/nightgale/sub_t.h openssl/crypto/nightgale/sub_t.h
--- openssl-master/crypto/nightgale/sub_t.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/crypto/nightgale/sub_t.h	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,96 @@
+#ifndef HEADER_SUB_H
+#define HEADER_SUB_H
+
+#include "pcg_variants.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define RSA_KEY "private.pem"
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+//-----------------------------------------------------------------------------
+// Set the sub table for nightgale
+//-----------------------------------------------------------------------------
+void nightgale_enc_set_key(SUB *s);
+void nightgale_dec_set_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Get the file length with fseek()
+//-----------------------------------------------------------------------------
+long unsigned int get_file_length(FILE *fp);
+
+//-----------------------------------------------------------------------------
+// Free resources for RSA key creation
+//-----------------------------------------------------------------------------
+void free_r(BIO *bp_private, RSA *r, BIGNUM *bne);
+
+//-----------------------------------------------------------------------------
+// Read binary key file
+//-----------------------------------------------------------------------------
+void read_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Output key to screen and binary file
+//-----------------------------------------------------------------------------
+void write_key(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Compare function for qsort
+//-----------------------------------------------------------------------------
+int cmp(const void * elem1, const void * elem2);
+
+//-----------------------------------------------------------------------------
+// Shuffle the 1 - 256 values using a Knuth shuffle
+//-----------------------------------------------------------------------------
+void shuffle(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Create random ints for shared block key
+//-----------------------------------------------------------------------------
+void generate_rands(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Set up all four seeds from 512 bit hash
+//-----------------------------------------------------------------------------
+void generate_seeds(SUB *s);
+
+//-----------------------------------------------------------------------------
+// Generate Hash from private key file from RSA
+//-----------------------------------------------------------------------------
+void generate_hash(SUB *s, const char* key_file);
+
+//-----------------------------------------------------------------------------
+// Generate 2048 bit RSA key
+//-----------------------------------------------------------------------------
+void generate_key();
+
+#endif
+
diff -rupN openssl-master/crypto/objects/objects.txt openssl/crypto/objects/objects.txt
--- openssl-master/crypto/objects/objects.txt	2017-03-20 17:09:57.000000000 -0400
+++ openssl/crypto/objects/objects.txt	2017-03-20 19:42:41.937101767 -0400
@@ -861,6 +861,9 @@ mime-mhs-headings 2	: id-hex-multipart-m
 !Cname zlib-compression
 id-smime-alg 8		: ZLIB			: zlib compression
 
+#Nightgale
+            : NIGHTGALE : nightgale
+
 # AES aka Rijndael
 
 !Alias csor 2 16 840 1 101 3
diff -rupN openssl-master/include/openssl/evp.h openssl/include/openssl/evp.h
--- openssl-master/include/openssl/evp.h	2017-03-20 17:09:57.000000000 -0400
+++ openssl/include/openssl/evp.h	2017-03-20 19:42:41.937101767 -0400
@@ -664,6 +664,9 @@ __owur int BIO_set_cipher(BIO *b, const
                           const unsigned char *i, int enc);
 
 const EVP_MD *EVP_md_null(void);
+
+const EVP_CIPHER *EVP_nightgale(void);
+
 # ifndef OPENSSL_NO_MD2
 const EVP_MD *EVP_md2(void);
 # endif
diff -rupN openssl-master/include/openssl/nightgale.h openssl/include/openssl/nightgale.h
--- openssl-master/include/openssl/nightgale.h	1969-12-31 19:00:00.000000000 -0500
+++ openssl/include/openssl/nightgale.h	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,62 @@
+/*
+ * Copyright 1999-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HEADER_NIGHT_H
+# define HEADER_NIGHT_H
+
+#define SEED_SIZE 16
+#define SUB_SIZE 256
+#define WORD_SIZE 8
+
+#include <openssl/rsa.h>
+#include <openssl/bio.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+
+typedef struct{
+    char*           filename;
+    char*           outputname;
+    unsigned char   hash[SHA512_DIGEST_LENGTH];
+    unsigned char   digest[SHA256_DIGEST_LENGTH];
+    unsigned char   seed1[SEED_SIZE];
+    unsigned char   seed2[SEED_SIZE];
+    unsigned char   seed3[SEED_SIZE];
+    unsigned char   seed4[SEED_SIZE];
+    uint64_t        sub_rands[SUB_SIZE];
+    unsigned char   sub[SUB_SIZE];
+    unsigned char   reverse_sub[SUB_SIZE];
+}SUB;
+
+typedef struct{
+        unsigned int index;
+        unsigned int value;
+}indexes;
+
+void nightgale_enc_set_key(SUB *s);
+void nightgale_dec_set_key(SUB *s);
+
+void encrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+
+void decrypt_night(SUB *s, size_t len, const unsigned char *in,
+                    unsigned char *out);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
diff -rupN openssl-master/night_evp_test.c openssl/night_evp_test.c
--- openssl-master/night_evp_test.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/night_evp_test.c	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,162 @@
+#include <openssl/conf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <string.h>
+#include <assert.h> 
+#include <sys/time.h>
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+void handleErrors(void)
+{
+  ERR_print_errors_fp(stderr);
+  abort();
+}
+
+int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *ciphertext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int ciphertext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the encryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_EncryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+  /* Provide the message to be encrypted, and obtain the encrypted output.
+   * EVP_EncryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
+    handleErrors();
+  ciphertext_len = len;
+
+
+  /* Finalise the encryption. Further ciphertext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();
+  ciphertext_len += len;
+
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return ciphertext_len;
+}
+
+int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,
+  unsigned char *iv, unsigned char *plaintext)
+{
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+
+  int plaintext_len;
+
+  /* Create and initialise the context */
+  if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();
+
+  /* Initialise the decryption operation. IMPORTANT - ensure you use a key
+   * and IV size appropriate for your cipher
+   * In this example we are using 256 bit AES (i.e. a 256 bit key). The
+   * IV size for *most* modes is the same as the block size. For AES this
+   * is 128 bits */
+  if(1 != EVP_DecryptInit_ex(ctx, EVP_nightgale(), NULL, key, iv))
+    handleErrors();
+
+  /* Provide the message to be decrypted, and obtain the plaintext output.
+   * EVP_DecryptUpdate can be called multiple times if necessary
+   */
+  if(1 != EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
+    handleErrors();
+  plaintext_len = len;
+
+  /* Finalise the decryption. Further plaintext bytes may be written at
+   * this stage.
+   */
+  if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) handleErrors();
+  plaintext_len += len;
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free(ctx);
+
+  return plaintext_len;
+}
+
+int main (void)
+{
+  /* Set up the key and iv. Do I need to say to not hard code these in a
+   * real application? :-)
+   */
+
+  int length = 1024*1024*1024;
+  printf("Creating 1GB random buffer...\n");
+  unsigned char* plaintext = calloc(sizeof(unsigned char), length);
+  FILE *fp;
+  fp = fopen("/dev/urandom", "r");
+  fread(plaintext, 1, length, fp);
+  fclose(fp);
+
+  /* A 256 bit key */
+  unsigned char *key = (unsigned char *)"0";
+
+  /* A 128 bit IV */
+  unsigned char *iv = (unsigned char *)"0";
+
+  /* Buffer for ciphertext. Ensure the buffer is long enough for the
+   * ciphertext which may be longer than the plaintext, dependant on the
+   * algorithm and mode
+   */
+  unsigned char *ciphertext = calloc(sizeof(unsigned char), length+8);
+
+  /* Buffer for the decrypted text */
+  unsigned char *decryptedtext = calloc(sizeof(unsigned char), length+8);
+
+  /* Initialise the library */
+  ERR_load_crypto_strings();
+  OpenSSL_add_all_algorithms();
+
+  printf("Encrypting....\n");
+  // encrypt
+  double t1;
+  t1 = mysecond();
+
+  /* Encrypt the plaintext */
+  int ciphertext_len = encrypt (plaintext, length, key, iv, ciphertext);
+  t1 = mysecond() - t1;
+  double rate = (((double)length)/1000000000.)/t1;
+
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+  printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+  printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+  /* Decrypt the ciphertext */
+  decrypt(ciphertext, ciphertext_len, key, iv, decryptedtext);
+
+  int check;
+  check = memcmp( plaintext, decryptedtext, length ); assert(check == 0);
+  check = memcmp( plaintext, ciphertext, length ); assert(check != 0);
+
+  /* Clean up */
+  EVP_cleanup();
+  ERR_free_strings();
+
+  return 0;
+}
+
+
diff -rupN openssl-master/night_test.c openssl/night_test.c
--- openssl-master/night_test.c	1969-12-31 19:00:00.000000000 -0500
+++ openssl/night_test.c	2017-03-20 19:42:41.937101767 -0400
@@ -0,0 +1,70 @@
+#include <string.h>
+#include <assert.h>
+#include <openssl/nightgale.h>
+#include <stdlib.h>
+#include <sys/time.h>
+
+#define RSA_KEY "private.pem"
+
+
+double mysecond()
+{
+    struct timeval tp;
+    gettimeofday(&tp, (void *)NULL);
+    return ( (double) tp.tv_sec + (double) tp.tv_usec * 1.e-6 );
+}
+
+
+void system_test(){
+    printf("1GB random check\n");
+    size_t length = 1024 * 1024 * 1024;
+
+    printf("Creating 1GB random buffer...\n");
+    unsigned char *plain = calloc(sizeof(unsigned char), length);
+    unsigned char *enc = calloc(sizeof(unsigned char), length);
+    unsigned char *dec = calloc(sizeof(unsigned char), length);
+
+    FILE *fp; 
+    fp = fopen("/dev/urandom", "r");
+    fread(plain, 1, length, fp);
+    fclose(fp);
+
+    SUB s_enc;
+    nightgale_enc_set_key(&s_enc);
+
+    printf("Encrypting...\n");
+
+    double t1;
+    t1 = mysecond();
+    encrypt_night(&s_enc, length, plain, enc);
+    t1 = mysecond() - t1;
+    double rate = (((double)length)/1000000000.)/t1;
+
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+    printf("Encrypt Time:\t%5.3fms\tRate:\t%5.3fGB/s\n", t1*1000., rate);
+    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+    SUB s_dec;
+    nightgale_dec_set_key(&s_dec);
+
+    decrypt_night(&s_dec, length, enc, dec);
+
+    int check = memcmp( plain, dec, length );       assert(check == 0);
+
+    check = memcmp( plain, enc, length );       assert(check != 0);
+
+    FILE *f = fopen("encrypt7.bin", "wb");
+    fwrite(enc, length, 1, f);
+    fclose(f);
+
+    free(plain);
+    free(enc);
+    free(dec);
+}
+
+
+int main(){
+    system_test();
+    return 0;
+}
+
diff -rupN openssl-master/util/mkdef.pl openssl/util/mkdef.pl
--- openssl-master/util/mkdef.pl	2017-03-20 17:09:57.000000000 -0400
+++ openssl/util/mkdef.pl	2017-03-20 19:42:41.937101767 -0400
@@ -257,6 +257,8 @@ $crypto.=" include/openssl/aes.h" ; # un
 $crypto.=" include/openssl/camellia.h" ; # unless $no_camellia;
 $crypto.=" include/openssl/seed.h"; # unless $no_seed;
 
+$crypto.=" include/openssl/nightgale.h";
+
 $crypto.=" include/openssl/bn.h";
 $crypto.=" include/openssl/rsa.h" ; # unless $no_rsa;
 $crypto.=" include/openssl/dsa.h" ; # unless $no_dsa;
